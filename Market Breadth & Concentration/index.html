<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Market Breadth & Concentration</title>

  <!-- Plotly (CDN) -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <style>
    :root{
      --maxw: 645px;     /* Gutenberg narrow block target */
      --pad: 12px;
      --border: #e6e6e6;
      --text: #111;
      --muted: #666;
      --bg: #fff;
    }

    body{
      margin:0;
      padding: var(--pad);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .page{
      max-width: var(--maxw);
      margin: 0 auto;
    }

    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:10px;
      padding:10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }

    .toolbar .left{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      align-items:center;
    }

    .toolbar label{
      font-size: 13px;
      color: var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }

    input[type="file"]{ font-size: 13px; }

    /* signal row (simple + compact) */
    .signal{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      justify-content:flex-start;
      margin: 6px 0 10px 0;
    }
    .signal .label{
      font-size:12px;
      color: var(--muted);
      margin-right:4px;
      white-space:nowrap;
    }
    .badge{
      font-size:12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 10px;
      background:#fff;
      white-space:nowrap;
    }
    .badge b{ font-weight:600; }

    .chart{
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: #fff;
    }

    .err{
      display:none;
      margin-top:10px;
      padding:10px;
      border:1px solid #f2c2c2;
      background:#fff3f3;
      border-radius:10px;
      font-size:13px;
      color:#7a0000;
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="toolbar">
      <div class="left">
        <label>
          Upload CSV:
          <input id="fileInput" type="file" accept=".csv,text/csv" />
        </label>

        <label>
          MMA window:
          <input id="mmaWindow" type="number" min="6" max="60" value="24" style="width:70px;" />
        </label>

        <label>
          LOESS smooth:
          <input id="loessFrac" type="number" min="0.05" max="0.50" step="0.01" value="0.18" style="width:70px;" />
        </label>
      </div>
    </div>

    <div id="signalRow" class="signal">
      <span class="label">Last 24 months:</span>
      <span class="badge" id="sigSummary">—</span>
    </div>

    <div id="err" class="err"></div>

    <div id="chartMain" class="chart"></div>
  </div>

<script>
/* -----------------------------
   Utilities
------------------------------ */

function showError(msg){
  const el = document.getElementById("err");
  el.style.display = "block";
  el.textContent = msg;
}
function clearError(){
  const el = document.getElementById("err");
  el.style.display = "none";
  el.textContent = "";
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

function parseCSV(text){
  // Minimal CSV parser (assumes no quoted commas)
  const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim().length);
  if(lines.length < 2) throw new Error("CSV appears empty.");

  const headers = lines[0].split(",").map(h => h.trim());
  const idxMonth = headers.findIndex(h => h.toLowerCase() === "month");
  const idxValue = headers.findIndex(h => h.toLowerCase() === "value");
  if(idxMonth === -1 || idxValue === -1) throw new Error("CSV must contain headers: Month, Value");

  const rows = [];
  for(let i=1; i<lines.length; i++){
    const parts = lines[i].split(",").map(x => x.trim());
    const m = parts[idxMonth];
    const v = parts[idxValue];
    if(!m || !v) continue;

    const monthStr = String(m).padStart(6, "0");
    const year = parseInt(monthStr.slice(0,4),10);
    const mon  = parseInt(monthStr.slice(4,6),10);
    const val  = Number(v);

    if(!Number.isFinite(year) || !Number.isFinite(mon) || !Number.isFinite(val)) continue;
    if(mon < 1 || mon > 12) continue;

    const date = new Date(Date.UTC(year, mon-1, 1));
    rows.push({ date, value: val });
  }
  if(rows.length === 0) throw new Error("No valid rows parsed.");
  rows.sort((a,b) => a.date - b.date);
  return rows;
}

function monthKey(d){
  return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,"0")}`;
}

function groupMonthly(rows){
  const bucket = new Map();
  for(const r of rows){
    const key = monthKey(r.date);
    if(!bucket.has(key)) bucket.set(key, { date: r.date, values: [] });
    bucket.get(key).values.push(r.value);
  }
  const months = Array.from(bucket.values()).sort((a,b)=>a.date-b.date);

  const dates = [];
  const mean = [];
  const median = [];

  for(const m of months){
    const vals = m.values.slice().sort((a,b)=>a-b);
    const len = vals.length;
    const mMean = vals.reduce((s,x)=>s+x,0) / len;
    const mMedian = (len % 2 === 1) ? vals[(len-1)/2] : (vals[len/2 - 1] + vals[len/2]) / 2;

    dates.push(m.date);
    mean.push(mMean);
    median.push(mMedian);
  }
  return { dates, mean, median };
}

function rollingMean(arr, window, minPeriods){
  const out = new Array(arr.length).fill(null);
  let sum = 0, count = 0;
  const q = []; // queue of {x, valid}
  for(let i=0; i<arr.length; i++){
    const x = arr[i];
    const valid = Number.isFinite(x);
    q.push({ x, valid });
    if(valid){ sum += x; count += 1; }

    if(q.length > window){
      const old = q.shift();
      if(old.valid){ sum -= old.x; count -= 1; }
    }
    if(count >= minPeriods) out[i] = sum / count;
  }
  return out;
}

function safeLog(x){
  if(!Number.isFinite(x) || x <= 0) return null;
  return Math.log(x);
}

/**
 * LOWESS/LOESS (simple Cleveland-style)
 */
function lowess(x, y, frac){
  const n = x.length;
  const yhat = new Array(n).fill(null);

  const idx = [];
  for(let i=0;i<n;i++){
    if(Number.isFinite(x[i]) && Number.isFinite(y[i])) idx.push(i);
  }
  if(idx.length < 10) return yhat;

  const m = idx.length;
  const r = Math.max(2, Math.floor(frac * m));

  function fitAt(k){
    const i0 = idx[k];
    const x0 = x[i0];

    const distances = idx.map(j => ({ j, d: Math.abs(x[j] - x0) }))
      .sort((a,b)=>a.d-b.d)
      .slice(0, r);

    const dmax = distances[distances.length - 1].d || 1;

    let sw=0, sx=0, sy=0, sxx=0, sxy=0;
    for(const {j,d} of distances){
      const u = d / dmax;
      const w = Math.pow(1 - Math.pow(u,3), 3);
      const xj = x[j], yj = y[j];
      sw  += w;
      sx  += w * xj;
      sy  += w * yj;
      sxx += w * xj * xj;
      sxy += w * xj * yj;
    }

    const denom = (sw * sxx - sx * sx);
    let a, b;
    if(Math.abs(denom) < 1e-12){
      a = sy / (sw || 1);
      b = 0;
    }else{
      b = (sw * sxy - sx * sy) / denom;
      a = (sy - b * sx) / sw;
    }
    yhat[i0] = a + b * x0;
  }

  for(let k=0;k<m;k++) fitAt(k);
  return yhat;
}

function computeChartHeight(){
  const maxw = 645;
  const page = document.querySelector(".page");
  const w = Math.min(page.clientWidth, maxw);
  return Math.round(clamp(w * 0.75, 360, 540));
}

function formatTick(val){
  if(!Number.isFinite(val) || val <= 0) return "";
  if(val >= 1e6){
    const x = val / 1e6;
    const s = (x >= 10) ? String(Math.round(x)) : (Math.round(x*10)/10).toString();
    return `${s}m`;
  }
  if(val >= 1e3){
    const x = val / 1e3;
    const s = (x >= 10) ? String(Math.round(x)) : (Math.round(x*10)/10).toString();
    return `${s}k`;
  }
  return String(Math.round(val));
}

function buildLogTicks(yMin, yMax){
  const bases = [1,2,5];
  const ticks = [];
  if(!(yMin>0) || !(yMax>0)) return { tickvals: [], ticktext: [] };

  const minExp = Math.floor(Math.log10(yMin));
  const maxExp = Math.ceil(Math.log10(yMax));

  for(let e=minExp; e<=maxExp; e++){
    for(const b of bases){
      const v = b * Math.pow(10, e);
      if(v >= yMin * 0.98 && v <= yMax * 1.02) ticks.push(v);
    }
  }
  const tickvals = Array.from(new Set(ticks)).sort((a,b)=>a-b);
  const ticktext = tickvals.map(formatTick);
  return { tickvals, ticktext };
}

/**
 * Single, simple signal:
 * - Is the mean/median gap widening or narrowing over last ~24 months (on MMA series)?
 * - Which side is driving it: mean rising faster, or median falling/lagging?
 */
function setSignalSummary(meanMMA, medianMMA, dates){
  const lookback = 24; // months
  const eps = 0.02;    // 2% deadband for direction

  // valid indices
  const valid = [];
  for(let i=0;i<dates.length;i++){
    if(Number.isFinite(meanMMA[i]) && Number.isFinite(medianMMA[i]) && meanMMA[i] > 0 && medianMMA[i] > 0){
      valid.push(i);
    }
  }
  const badge = document.getElementById("sigSummary");

  if(valid.length < 6){
    badge.textContent = "—";
    return;
  }

  const end = valid[valid.length - 1];
  const start = valid[Math.max(0, valid.length - lookback)];

  const mean0 = meanMMA[start], mean1 = meanMMA[end];
  const med0  = medianMMA[start], med1  = medianMMA[end];

  const gap0 = mean0 / med0;
  const gap1 = mean1 / med1;

  const dGap = (gap1 - gap0) / gap0;
  const dMean = (mean1 - mean0) / mean0;
  const dMed  = (med1 - med0) / med0;

  function arrow(chg){
    if(chg > eps) return "↑";
    if(chg < -eps) return "↓";
    return "→";
  }

  const gapArrow = arrow(dGap);

  // Driver logic (kept blunt, not over-analytical)
  // If gap is widening, it can be because mean is rising faster OR median is falling/lagging.
  // If narrowing, median catching up OR mean easing.
  let driver = "mixed";
  if(Math.abs(dGap) <= eps){
    driver = "stable";
  }else if(dGap > eps){
    // widening
    if(dMean - dMed > 0.03) driver = "mean leading";
    else if(dMed < -0.02) driver = "median weakening";
    else driver = "mean outrunning median";
  }else{
    // narrowing
    if(dMed - dMean > 0.03) driver = "median catching up";
    else if(dMean < -0.02) driver = "mean easing";
    else driver = "median outrunning mean";
  }

  badge.innerHTML = `<b>Gap:</b> ${gapArrow} &nbsp; <span style="color:var(--muted)">(${driver})</span>`;
}

/* -----------------------------
   Plotting
------------------------------ */

function render(rows){
  clearError();

  const mmaWindow = clamp(parseInt(document.getElementById("mmaWindow").value,10) || 24, 6, 60);
  const frac = clamp(parseFloat(document.getElementById("loessFrac").value) || 0.18, 0.05, 0.50);

  const { dates, mean, median } = groupMonthly(rows);

  const minPeriods = Math.min(12, mmaWindow);
  const meanMMA = rollingMean(mean, mmaWindow, minPeriods);
  const medianMMA = rollingMean(median, mmaWindow, minPeriods);

  // Single summary signal
  setSignalSummary(meanMMA, medianMMA, dates);

  // numeric x for LOESS
  const t0 = dates[0].getTime();
  const xNum = dates.map(d => (d.getTime() - t0) / (1000*60*60*24));

  // LOESS on log(MMA)
  const logMeanMMA = meanMMA.map(safeLog);
  const logMedianMMA = medianMMA.map(safeLog);

  const loessLogMean = lowess(xNum, logMeanMMA, frac);
  const loessLogMedian = lowess(xNum, logMedianMMA, frac);

  const loessMean = loessLogMean.map(v => Number.isFinite(v) ? Math.exp(v) : null);
  const loessMedian = loessLogMedian.map(v => Number.isFinite(v) ? Math.exp(v) : null);

  // y ticks (log, compact labels)
  const yVals = []
    .concat(meanMMA, medianMMA, loessMean, loessMedian)
    .filter(v => Number.isFinite(v) && v > 0);

  const yMin = Math.min(...yVals);
  const yMax = Math.max(...yVals);
  const ticks = buildLogTicks(yMin, yMax);

  const h = computeChartHeight();

  const traces = [
    { x: dates, y: meanMMA,   type:"scatter", mode:"lines", name:`Mean (${mmaWindow}M moving avg)`,   line:{width:1} },
    { x: dates, y: medianMMA, type:"scatter", mode:"lines", name:`Median (${mmaWindow}M moving avg)`, line:{width:1} },
    { x: dates, y: loessMean, type:"scatter", mode:"lines", name:"LOESS regression on Mean MMA",      line:{width:2} },
    { x: dates, y: loessMedian,type:"scatter",mode:"lines", name:"LOESS regression on Median MMA",    line:{width:2} }
  ];

  const layout = {
    height: h,
    margin: { l: 62, r: 18, t: 12, b: 52 },
    paper_bgcolor: "#ffffff",
    plot_bgcolor: "#ffffff",

    showlegend: true,
    legend: {
      orientation: "h",
      x: 0, xanchor: "left",
      y: 1.10, yanchor: "top"
    },

    xaxis: {
      title: "",
      showgrid: true,
      gridcolor: "rgba(0,0,0,0.08)",
      tickformat: "%Y",
      dtick: "M24"
    },

    yaxis: {
      title: "GBP (log scale)",
      type: "log",
      showgrid: true,
      gridcolor: "rgba(0,0,0,0.08)",
      tickvals: ticks.tickvals,
      ticktext: ticks.ticktext
    }
  };

  const config = {
    responsive: true,
    displaylogo: false,
    modeBarButtonsToRemove: ["lasso2d", "select2d"]
  };

  Plotly.newPlot("chartMain", traces, layout, config);
}

/* -----------------------------
   File upload + re-render wiring
------------------------------ */

document.getElementById("fileInput").addEventListener("change", (ev) => {
  const file = ev.target.files?.[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try{
      const text = String(reader.result || "");
      const rows = parseCSV(text);
      render(rows);
    }catch(e){
      showError(e.message || String(e));
    }
  };
  reader.onerror = () => showError("Could not read file.");
  reader.readAsText(file);
});

let lastRows = null;
const _render = render;
render = function(rows){ lastRows = rows; return _render(rows); };

function tryRerender(){
  if(!lastRows) return;
  try{ render(lastRows); }catch(e){ showError(e.message || String(e)); }
}

document.getElementById("mmaWindow").addEventListener("change", tryRerender);
document.getElementById("loessFrac").addEventListener("change", tryRerender);
window.addEventListener("resize", tryRerender);

// No demo data auto-load; chart appears after CSV upload.
</script>
</body>
</html>
