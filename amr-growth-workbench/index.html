<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AMR Internal: Growth Workbench (Mean/Median + Concentration + Tooltips)</title>

  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    :root{
      --bg:#ffffff; --fg:#111; --muted:#666; --card:#f6f6f7; --line:#e5e5e7;
      --btn:#111; --btnfg:#fff; --shadow:0 6px 18px rgba(0,0,0,.08); --radius:14px;
    }
    body{margin:0;padding:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:transparent;color:var(--fg);}
    .wrap{max-width:1180px;margin:0 auto;}
    .title{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap;}
    .title h1{font-size:18px;margin:0;}
    .title .sub{color:var(--muted);font-size:12px;}
    .panel{margin-top:12px;background:var(--bg);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px;}
    input[type="file"]{height:40px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;max-width:340px;}
    select,input[type="number"]{height:40px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;min-width:160px;}
    .btn{height:40px;padding:8px 12px;border-radius:12px;border:1px solid var(--btn);background:var(--btn);color:var(--btnfg);cursor:pointer;font-weight:600;}
    .btn:disabled{opacity:.5;cursor:not-allowed;}
    .grid{display:grid;grid-template-columns:1.35fr .65fr;gap:12px;}
    @media (max-width:980px){.grid{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:10px;}
    .card h3{margin:0 0 6px 0;font-size:13px;}
    .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;}
    .kpi{background:#fff;border:1px solid var(--line);border-radius:12px;padding:8px 10px;position:relative;}
    .kpi .lab{font-size:11px;color:var(--muted);}
    .kpi .val{font-size:14px;font-weight:700;margin-top:2px;}
    .note{font-size:12px;color:var(--muted);line-height:1.35;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--line);background:#fff;cursor:pointer;font-weight:600;font-size:12px;}
    .tab.active{border-color:#111;}
    .tableWrap{overflow:auto;border:1px solid var(--line);border-radius:var(--radius);background:#fff;}
    table{border-collapse:collapse;width:100%;min-width:1160px;font-size:12px;}
    th,td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;white-space:nowrap;}
    th{background:#fafafa;position:sticky;top:0;z-index:1;}
    tr:hover td{background:#fbfbff;}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;font-size:11px;color:var(--muted);}

    /* Tooltip */
    .kpi[data-tip]{cursor:help;}
    .kpi[data-tip]:hover::after{
      content: attr(data-tip);
      position:absolute;
      left:0;
      top:100%;
      margin-top:8px;
      width:min(380px, 75vw);
      padding:10px 12px;
      background:#111;
      color:#fff;
      border-radius:12px;
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
      z-index:999;
      box-shadow:0 10px 24px rgba(0,0,0,.25);
    }
    .kpi[data-tip]:hover::before{
      content:"";
      position:absolute;
      left:14px;
      top:100%;
      margin-top:2px;
      border:8px solid transparent;
      border-bottom-color:#111;
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="title">
    <h1>AMR Internal: Growth Workbench</h1>
    <div class="sub">Lot-level upload → mean/median + lots → trend CAGR + Mcap proxy + concentration + KPI tooltips</div>
  </div>

  <div class="panel">
    <div class="controls">
      <input id="file" type="file" accept=".csv,text/csv" />
      <select id="artistSelect" disabled>
        <option value="">Upload data first…</option>
      </select>

      <label class="pill">Min lots / 24M</label>
      <input id="minLots24" type="number" value="50" min="0" step="1" />

      <label class="pill">Rolling (months)</label>
      <input id="rollM" type="number" value="12" min="1" step="1" />

      <label class="pill">Extra smooth (months)</label>
      <input id="smoothM" type="number" value="5" min="1" step="1" />

      <label class="pill">Trend window (months)</label>
      <input id="trendM" type="number" value="60" min="12" step="1" />

      <button id="btnRecalc" class="btn" disabled>Recalculate</button>
      <button id="btnTop" class="btn" disabled>Show Top Artists</button>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Mean & Median Price (Rolling + Smoothed) with Log-Linear Trends</h3>
        <div id="chartPrice" style="height:440px;"></div>
        <div class="note">
          Pipeline: lot-level → monthly mean + monthly median + lots → rolling + smoothing → log-linear trend (window you set).
        </div>
      </div>

      <div class="card">
        <h3>KPIs (Selected Artist)</h3>
        <div class="kpis" id="kpis"></div>

        <div style="height:10px;"></div>
        <h3>Market-cap Proxy (Price × Lots)</h3>
        <div id="chartMcap" style="height:230px;"></div>

        <div style="height:10px;"></div>
        <h3>Concentration (Top Decile Value Share)</h3>
        <div id="chartConc" style="height:230px;"></div>
      </div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="cagr">Top by Mean CAGR</div>
      <div class="tab" data-tab="abs">Top by Abs Δ Mean Price</div>
      <div class="tab" data-tab="mcap">Top by Abs Δ Mcap</div>
      <div class="tab" data-tab="r2">Top by Trend Strength (R²)</div>
      <div class="tab" data-tab="conc">Top by Concentration Increase</div>
    </div>

    <div class="card" style="margin-top:10px;">
      <h3>Rankings</h3>
      <div class="tableWrap">
        <table id="rankTable">
          <thead><tr>
            <th>Rank</th>
            <th>Artist</th>
            <th>Mean CAGR</th>
            <th>Median CAGR</th>
            <th>Mean–Median CAGR Δ</th>
            <th>Mean/Median Ratio Shift</th>
            <th>Abs Δ Mean Price</th>
            <th>Abs Δ Mcap</th>
            <th>Top-Decile Share (Latest Yr)</th>
            <th>Δ Top-Decile Share (Window)</th>
            <th>R² (Mean)</th>
            <th>Lots (last 24M)</th>
            <th>Lots (last 12M)</th>
          </tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="note" style="margin-top:8px;">
        Eligibility: at least <span id="minLotsEcho">50</span> lots in the last 24 months.
      </div>
    </div>
  </div>
</div>

<script>
/* ============================
   Utilities
============================ */
function parseNumberLoose(v){
  if(v === null || v === undefined) return NaN;
  const s = String(v).trim().replace(/[£$€]/g,'').replace(/,/g,'').replace(/\s+/g,'');
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}
function splitCSVLine(line){
  const out = [];
  let cur = "", inQ = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    }else if(ch === "," && !inQ){
      out.push(cur); cur = "";
    }else{
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function ymToDate(yyyymm){
  const s = String(yyyymm).trim();
  if(!/^\d{6}$/.test(s)) return null;
  const y = Number(s.slice(0,4));
  const m = Number(s.slice(4,6));
  if(!(y>=1900 && m>=1 && m<=12)) return null;
  return new Date(Date.UTC(y, m-1, 1));
}
function monthDiff(a, b){
  return (b.getUTCFullYear()-a.getUTCFullYear())*12 + (b.getUTCMonth()-a.getUTCMonth());
}
function rollingMean(arr, win){
  const out = [], q = [];
  let sum = 0, cnt = 0;
  for(let i=0;i<arr.length;i++){
    const y = arr[i].y;
    q.push(y);
    if(Number.isFinite(y)){ sum += y; cnt += 1; }
    if(q.length > win){
      const old = q.shift();
      if(Number.isFinite(old)){ sum -= old; cnt -= 1; }
    }
    const val = (q.length === win && cnt > 0) ? (sum / cnt) : NaN;
    out.push({x: arr[i].x, y: val});
  }
  return out;
}
function rollingSum(arr, win){
  const out = [], q = [];
  let sum = 0;
  for(let i=0;i<arr.length;i++){
    const y = Number.isFinite(arr[i].y) ? arr[i].y : 0;
    q.push(y);
    sum += y;
    if(q.length > win) sum -= q.shift();
    out.push({x: arr[i].x, y: (q.length===win)?sum:NaN});
  }
  return out;
}
function ols(x, y){
  const n = x.length;
  if(n < 3) return null;
  let sx=0, sy=0, sxx=0, sxy=0;
  for(let i=0;i<n;i++){ sx+=x[i]; sy+=y[i]; sxx+=x[i]*x[i]; sxy+=x[i]*y[i]; }
  const denom = (n*sxx - sx*sx);
  if(Math.abs(denom) < 1e-12) return null;
  const b = (n*sxy - sx*sy)/denom;
  const a = (sy - b*sx)/n;

  const yhat = x.map(t => a + b*t);
  const ybar = sy/n;
  let ssTot=0, ssRes=0;
  for(let i=0;i<n;i++){
    ssTot += (y[i]-ybar)*(y[i]-ybar);
    ssRes += (y[i]-yhat[i])*(y[i]-yhat[i]);
  }
  const r2 = ssTot > 0 ? 1 - (ssRes/ssTot) : NaN;
  return {a,b,r2};
}
function fmtPct(v){ return Number.isFinite(v) ? (v*100).toFixed(1)+"%" : "—"; }
function fmtShare(v){ return Number.isFinite(v) ? (v*100).toFixed(1)+"%" : "—"; }
function fmtNum(v){
  if(!Number.isFinite(v)) return "—";
  const abs = Math.abs(v);
  if(abs >= 1e9) return (v/1e9).toFixed(2)+"B";
  if(abs >= 1e6) return (v/1e6).toFixed(2)+"M";
  if(abs >= 1e3) return (v/1e3).toFixed(2)+"k";
  return Math.round(v).toString();
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}
function quantile(sortedArr, q){
  if(!sortedArr.length) return NaN;
  const pos = (sortedArr.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if(sortedArr[base+1] === undefined) return sortedArr[base];
  return sortedArr[base] + rest * (sortedArr[base+1] - sortedArr[base]);
}
function percentileRank(sortedArr, v){
  if(!sortedArr.length || !Number.isFinite(v)) return NaN;
  let lo = 0, hi = sortedArr.length;
  while(lo < hi){
    const mid = (lo + hi) >> 1;
    if(sortedArr[mid] <= v) lo = mid + 1;
    else hi = mid;
  }
  return (lo / sortedArr.length) * 100;
}

/* ============================
   State
============================ */
let lotRows = [];
let monthlyByArtist = new Map();
let annualByArtist = new Map();
let artists = [];
let metricsByArtist = new Map();
let currentArtist = null;

// Benchmarks across eligible artists for context
let bench = {
  ratioShift: {arr:[], p50:NaN, p75:NaN, p90:NaN},
  cagrDiv:    {arr:[], p50:NaN, p75:NaN, p90:NaN},
  concDelta:  {arr:[], p50:NaN, p75:NaN, p90:NaN},
  meanCagr:   {arr:[], p50:NaN, p75:NaN, p90:NaN},
};

const els = {
  file: document.getElementById("file"),
  artistSelect: document.getElementById("artistSelect"),
  minLots24: document.getElementById("minLots24"),
  rollM: document.getElementById("rollM"),
  smoothM: document.getElementById("smoothM"),
  trendM: document.getElementById("trendM"),
  btnRecalc: document.getElementById("btnRecalc"),
  btnTop: document.getElementById("btnTop"),
  kpis: document.getElementById("kpis"),
  rankBody: document.querySelector("#rankTable tbody"),
  tabs: Array.from(document.querySelectorAll(".tab")),
  minLotsEcho: document.getElementById("minLotsEcho"),
};

/* ============================
   Parse lot-level CSV
============================ */
function parseLotCSV(text){
  const lines = text.replace(/\r/g,'').split("\n").filter(l => l.trim().length);
  if(lines.length < 2) return [];

  const headers = splitCSVLine(lines[0]).map(h => h.trim());
  const idx = (name) => headers.findIndex(h => h.toLowerCase() === name.toLowerCase());

  const iID = idx("ArtistID");
  const iName = idx("ArtistName");
  const iMonth = idx("MonthYYY");
  const iVal = idx("ValueGBP");

  if(iID < 0 || iName < 0 || iMonth < 0 || iVal < 0){
    throw new Error("CSV must include headers: ArtistID, ArtistName, MonthYYY, ValueGBP");
  }

  const rows = [];
  for(let i=1;i<lines.length;i++){
    const cells = splitCSVLine(lines[i]);
    const id = (cells[iID] ?? "").trim();
    const name = (cells[iName] ?? "").trim();
    const dt = ymToDate(cells[iMonth]);
    const price = parseNumberLoose(cells[iVal]);
    if(!id || !name || !dt || !Number.isFinite(price) || price <= 0) continue;
    rows.push({id, name, date: dt, price});
  }
  return rows;
}

/* ============================
   Aggregate: Monthly mean/median/lots + Annual price lists
============================ */
function buildAggregates(){
  monthlyByArtist = new Map();
  annualByArtist = new Map();

  const monthMap = new Map(); // akey -> monthTime -> {sum,cnt,prices[]}
  let minD = null, maxD = null;

  for(const r of lotRows){
    if(!minD || r.date < minD) minD = r.date;
    if(!maxD || r.date > maxD) maxD = r.date;

    const akey = `${r.id}|${r.name}`;
    const mkey = r.date.getTime();

    if(!monthMap.has(akey)) monthMap.set(akey, new Map());
    const mm = monthMap.get(akey);
    if(!mm.has(mkey)) mm.set(mkey, {sum:0, cnt:0, prices:[]});
    const agg = mm.get(mkey);
    agg.sum += r.price;
    agg.cnt += 1;
    agg.prices.push(r.price);

    const yr = r.date.getUTCFullYear();
    if(!annualByArtist.has(akey)) annualByArtist.set(akey, new Map());
    const am = annualByArtist.get(akey);
    if(!am.has(yr)) am.set(yr, []);
    am.get(yr).push(r.price);
  }

  // Global monthly timeline so rolling windows align
  const timeline = [];
  let cur = new Date(Date.UTC(minD.getUTCFullYear(), minD.getUTCMonth(), 1));
  const end = new Date(Date.UTC(maxD.getUTCFullYear(), maxD.getUTCMonth(), 1));
  while(cur <= end){
    timeline.push(new Date(cur));
    cur = new Date(Date.UTC(cur.getUTCFullYear(), cur.getUTCMonth()+1, 1));
  }

  for(const [akey, mm] of monthMap.entries()){
    const series = [];
    for(const dt of timeline){
      const k = dt.getTime();
      const agg = mm.get(k);
      if(agg){
        const prices = agg.prices.slice().sort((a,b)=>a-b);
        const mid = Math.floor(prices.length/2);
        const median = (prices.length % 2) ? prices[mid] : (prices[mid-1] + prices[mid]) / 2;
        series.push({date: dt, meanPrice: agg.sum / agg.cnt, medianPrice: median, lots: agg.cnt});
      }else{
        series.push({date: dt, meanPrice: NaN, medianPrice: NaN, lots: 0});
      }
    }
    monthlyByArtist.set(akey, series);
  }

  artists = Array.from(monthlyByArtist.keys()).sort((a,b)=>{
    const an = a.split("|")[1].toLowerCase();
    const bn = b.split("|")[1].toLowerCase();
    return an.localeCompare(bn);
  });
}

/* ============================
   Concentration: top 10% value share per year
============================ */
function topDecileShare(prices){
  if(!prices || prices.length < 10) return NaN; // too few
  const sorted = prices.slice().sort((a,b)=>a-b);
  const n = sorted.length;
  const k = Math.max(1, Math.ceil(n * 0.10));
  let total = 0;
  for(const v of sorted) total += v;
  if(total <= 0) return NaN;
  let top = 0;
  for(let i=n-k;i<n;i++) top += sorted[i];
  return top / total;
}

/* ============================
   Metrics per artist
============================ */
function computeMetrics(akey, params){
  const series = monthlyByArtist.get(akey);
  if(!series || series.length < 24) return null;

  const roll = params.rollM;
  const smooth = params.smoothM;
  const trendWin = params.trendM;

  const meanArr = series.map(d => ({x:d.date, y:d.meanPrice}));
  const medianArr = series.map(d => ({x:d.date, y:d.medianPrice}));
  const lotsMonthlyArr = series.map(d => ({x:d.date, y:d.lots}));

  const rollMean = rollingMean(meanArr, roll);
  const smoothMean = rollingMean(rollMean, smooth);

  const rollMedian = rollingMean(medianArr, roll);
  const smoothMedian = rollingMean(rollMedian, smooth);

  const rollLots = rollingSum(lotsMonthlyArr, roll);
  const smoothLots = rollingMean(rollLots, smooth);

  const mcap = smoothMean.map((pt,i)=>{
    const L = smoothLots[i]?.y;
    const y = (Number.isFinite(pt.y) && Number.isFinite(L)) ? (pt.y * L) : NaN;
    return {x: pt.x, y};
  });

  // Liquidity counts
  const lastDate = series[series.length-1].date;
  const last24Start = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-23, 1));
  const last12Start = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-11, 1));
  let lots24=0, lots12=0;
  for(const d of series){
    if(d.date >= last24Start) lots24 += d.lots;
    if(d.date >= last12Start) lots12 += d.lots;
  }
  const eligible = lots24 >= params.minLots24;

  // Trend start
  const startTrend = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-(trendWin-1), 1));

  // Mean trend
  const x=[], y=[];
  for(const pt of smoothMean){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    x.push(monthDiff(startTrend, pt.x));
    y.push(Math.log(pt.y));
  }
  const fit = ols(x,y);

  let meanCagr=NaN, r2=NaN, meanStart=NaN, meanEnd=NaN, absDelta=NaN;
  const meanTrendLine = smoothMean.map(pt => ({x:pt.x, y:NaN}));

  if(fit){
    r2 = fit.r2;
    meanCagr = Math.exp(fit.b * 12) - 1;
    const t0=0, t1=trendWin-1;
    meanStart = Math.exp(fit.a + fit.b*t0);
    meanEnd   = Math.exp(fit.a + fit.b*t1);
    absDelta  = meanEnd - meanStart;

    for(let i=0;i<meanTrendLine.length;i++){
      const dt = meanTrendLine[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      meanTrendLine[i].y = Math.exp(fit.a + fit.b*t);
    }
  }

  // Median trend
  const xm=[], ym=[];
  for(const pt of smoothMedian){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    xm.push(monthDiff(startTrend, pt.x));
    ym.push(Math.log(pt.y));
  }
  const fitMed = ols(xm, ym);

  let medianCagr=NaN, medianStart=NaN, medianEnd=NaN;
  const medianTrendLine = smoothMedian.map(pt => ({x:pt.x, y:NaN}));

  if(fitMed){
    medianCagr = Math.exp(fitMed.b * 12) - 1;
    const t0=0, t1=trendWin-1;
    medianStart = Math.exp(fitMed.a + fitMed.b*t0);
    medianEnd   = Math.exp(fitMed.a + fitMed.b*t1);

    for(let i=0;i<medianTrendLine.length;i++){
      const dt = medianTrendLine[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      medianTrendLine[i].y = Math.exp(fitMed.a + fitMed.b*t);
    }
  }

  const cagrDivergence = (Number.isFinite(meanCagr) && Number.isFinite(medianCagr)) ? (meanCagr - medianCagr) : NaN;

  let ratioShift=NaN;
  if(Number.isFinite(meanStart) && Number.isFinite(medianStart) && Number.isFinite(meanEnd) && Number.isFinite(medianEnd) && medianStart>0 && medianEnd>0){
    const ratioStart = meanStart / medianStart;
    const ratioEnd = meanEnd / medianEnd;
    ratioShift = ratioEnd - ratioStart;
  }

  // Mcap trend delta
  const xk=[], yk=[];
  for(const pt of mcap){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    xk.push(monthDiff(startTrend, pt.x));
    yk.push(Math.log(pt.y));
  }
  const fitM = ols(xk, yk);
  let mcapDelta=NaN;
  const mcapTrend = mcap.map(pt => ({x:pt.x, y:NaN}));
  if(fitM){
    const t0=0, t1=trendWin-1;
    const m0 = Math.exp(fitM.a + fitM.b*t0);
    const m1 = Math.exp(fitM.a + fitM.b*t1);
    mcapDelta = m1 - m0;

    for(let i=0;i<mcapTrend.length;i++){
      const dt = mcapTrend[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      mcapTrend[i].y = Math.exp(fitM.a + fitM.b*t);
    }
  }

  // Concentration series within window years
  const startYear = startTrend.getUTCFullYear();
  const endYear = lastDate.getUTCFullYear();
  const annualMap = annualByArtist.get(akey) || new Map();

  const concSeries = [];
  for(let yr=startYear; yr<=endYear; yr++){
    const prices = annualMap.get(yr);
    const share = topDecileShare(prices);
    if(Number.isFinite(share)) concSeries.push({year: yr, share});
  }

  let concLatest = NaN, concDeltaWin = NaN;
  if(concSeries.length >= 2){
    concLatest = concSeries[concSeries.length-1].share;
    concDeltaWin = concSeries[concSeries.length-1].share - concSeries[0].share;
  }else if(concSeries.length === 1){
    concLatest = concSeries[0].share;
  }

  return {
    akey,
    artistName: akey.split("|")[1],
    eligible,
    lots24, lots12,

    smoothMean,
    meanTrendLine,
    smoothMedian,
    medianTrendLine,

    meanCagr,
    medianCagr,
    cagrDivergence,
    ratioShift,

    absDelta,
    r2,

    mcap,
    mcapTrend,
    mcapDelta,

    concSeries,
    concLatest,
    concDeltaWin
  };
}

function recalcAll(){
  const params = {
    minLots24: Math.max(0, Number(els.minLots24.value || 0)),
    rollM: Math.max(1, Number(els.rollM.value || 12)),
    smoothM: Math.max(1, Number(els.smoothM.value || 5)),
    trendM: Math.max(12, Number(els.trendM.value || 60))
  };
  els.minLotsEcho.textContent = String(params.minLots24);

  metricsByArtist = new Map();
  for(const a of artists){
    const m = computeMetrics(a, params);
    if(m) metricsByArtist.set(a, m);
  }

  // Build benchmarks across eligible artists (current settings)
  const elig = Array.from(metricsByArtist.values()).filter(m => m.eligible);

  function buildDist(getter){
    const a = elig.map(getter).filter(Number.isFinite).sort((x,y)=>x-y);
    return { arr:a, p50:quantile(a,0.50), p75:quantile(a,0.75), p90:quantile(a,0.90) };
  }
  bench.meanCagr  = buildDist(m => m.meanCagr);
  bench.cagrDiv   = buildDist(m => m.cagrDivergence);
  bench.ratioShift= buildDist(m => m.ratioShift);
  bench.concDelta = buildDist(m => m.concDeltaWin);

  if(currentArtist && metricsByArtist.has(currentArtist)) renderArtist(currentArtist);
  renderRankings("cagr");
}

/* ============================
   Rendering
============================ */
function renderArtist(akey){
  const m = metricsByArtist.get(akey);
  if(!m) return;

  const trendM = Math.max(12, Number(els.trendM.value || 60));
  const yearsApprox = (trendM/12);
  const winLabel = `${trendM} months (≈ ${yearsApprox.toFixed(1)}y)`;

  const prMeanCagr  = percentileRank(bench.meanCagr.arr, m.meanCagr);
  const prCagrDiv   = percentileRank(bench.cagrDiv.arr, m.cagrDivergence);
  const prRatio     = percentileRank(bench.ratioShift.arr, m.ratioShift);
  const prConcDelta = percentileRank(bench.concDelta.arr, m.concDeltaWin);

  function kpiCard(label, value, tip){
    return `
      <div class="kpi" data-tip="${escapeHtml(tip)}">
        <div class="lab">${escapeHtml(label)}</div>
        <div class="val">${escapeHtml(value)}</div>
      </div>
    `;
  }

  const tipMeanCagr =
`Mean CAGR (trend-based)
Annualised compounded growth from a log-linear trend fitted to the SMOOTHED rolling MEAN price over the last ${winLabel}.
Higher % = faster compounding. Use R² as a reliability check.
Benchmark (eligible): p50 ${fmtPct(bench.meanCagr.p50)}, p75 ${fmtPct(bench.meanCagr.p75)}, p90 ${fmtPct(bench.meanCagr.p90)}.
Percentile: ${Number.isFinite(prMeanCagr) ? prMeanCagr.toFixed(0) : "—"}th.`;

  const tipMedianCagr =
`Median CAGR (trend-based)
Same method as mean CAGR, but using the SMOOTHED rolling MEDIAN price over the last ${winLabel}.
If median is flat while mean rises, the move is trophy-led rather than broad-based.`;

  const tipCagrDiv =
`Mean–Median CAGR Δ
Difference: (Mean CAGR − Median CAGR) over ${winLabel}.
Positive = upper-tier works pulling away; near zero = broad-based repricing.
Benchmark: p50 ${fmtPct(bench.cagrDiv.p50)}, p75 ${fmtPct(bench.cagrDiv.p75)}, p90 ${fmtPct(bench.cagrDiv.p90)}.
Percentile: ${Number.isFinite(prCagrDiv) ? prCagrDiv.toFixed(0) : "—"}th.`;

  const tipRatioShift =
`Mean/Median Ratio Shift
Change in (Mean ÷ Median) between the START and END of the trend window (${winLabel}), using trend-predicted levels.
0 ≈ stable distribution; positive = widening (more top-end dominance); negative = compression.
Not bounded to 0–1; interpret relative to benchmark.
Benchmark: p50 ${Number.isFinite(bench.ratioShift.p50)?bench.ratioShift.p50.toFixed(2):"—"}, p75 ${Number.isFinite(bench.ratioShift.p75)?bench.ratioShift.p75.toFixed(2):"—"}, p90 ${Number.isFinite(bench.ratioShift.p90)?bench.ratioShift.p90.toFixed(2):"—"}.
Percentile: ${Number.isFinite(prRatio) ? prRatio.toFixed(0) : "—"}th.`;

  const tipAbsDelta =
`Abs Δ Mean Price (trend-based)
Predicted end price minus predicted start price from the MEAN-price trendline over ${winLabel}.
This is “GBP level change” (magnitude), not % growth.`;

  const tipMcapDelta =
`Abs Δ Mcap Proxy (trend-based)
Change in (smoothed mean price × smoothed rolling lots) using trend-predicted start/end over ${winLabel}.
Captures economic weight: price change supported by volume.`;

  const tipConcLatest =
`Top-Decile Share (Latest Yr)
In the latest year within the window: share of TOTAL annual value captured by the TOP 10% of lots (by price).
Higher share = more trophy concentration.`;

  const tipConcDelta =
`Δ Top-Decile Share (Window)
Change in top-decile value share from first→last available year inside the trend window (${winLabel}).
Positive = concentration rising; negative = distribution broadening.
Benchmark: p50 ${fmtShare(bench.concDelta.p50)}, p75 ${fmtShare(bench.concDelta.p75)}, p90 ${fmtShare(bench.concDelta.p90)}.
Percentile: ${Number.isFinite(prConcDelta) ? prConcDelta.toFixed(0) : "—"}th.`;

  const tipR2 =
`R² (Mean trend)
How well the smoothed log-mean series fits a straight-line trend over ${winLabel}.
Closer to 1 = cleaner, more consistent regime; low values = noisy/cyclical.`;

  const tipLots24 =
`Lots (last 24 months)
Count of lots in the last 24 months. Used for eligibility (liquidity threshold).`;

  const tipLots12 =
`Lots (last 12 months)
Short-term liquidity check. A falling count can make trends look less stable.`;

  const tipElig =
`Eligibility
Included in rankings if Lots (last 24M) ≥ ${Number(els.minLots24.value)}.`;

  els.kpis.innerHTML = [
    kpiCard("Mean CAGR (trend-based)", fmtPct(m.meanCagr), tipMeanCagr),
    kpiCard("Median CAGR (trend-based)", fmtPct(m.medianCagr), tipMedianCagr),
    kpiCard("Mean–Median CAGR Δ", fmtPct(m.cagrDivergence), tipCagrDiv),
    kpiCard("Mean/Median Ratio Shift", Number.isFinite(m.ratioShift) ? m.ratioShift.toFixed(2) : "—", tipRatioShift),
    kpiCard("Abs Δ Mean Price", fmtNum(m.absDelta), tipAbsDelta),
    kpiCard("Abs Δ Mcap", fmtNum(m.mcapDelta), tipMcapDelta),
    kpiCard("Top-Decile Share (Latest Yr)", fmtShare(m.concLatest), tipConcLatest),
    kpiCard("Δ Top-Decile Share (Window)", fmtShare(m.concDeltaWin), tipConcDelta),
    kpiCard("Trend strength (R², mean)", Number.isFinite(m.r2) ? m.r2.toFixed(2) : "—", tipR2),
    kpiCard("Lots (last 24M)", fmtNum(m.lots24), tipLots24),
    kpiCard("Lots (last 12M)", fmtNum(m.lots12), tipLots12),
    kpiCard("Eligibility", m.eligible ? "Yes" : "No", tipElig),
  ].join("");

  // Price chart (mean + trend, median + trend)
  const x = m.smoothMean.map(p => p.x);
  Plotly.newPlot("chartPrice", [
    {x, y: m.smoothMean.map(p=>p.y), type:"scatter", mode:"lines", name:"Mean (smoothed rolling)"},
    {x, y: m.meanTrendLine.map(p=>p.y), type:"scatter", mode:"lines", name:"Mean trend"},
    {x, y: m.smoothMedian.map(p=>p.y), type:"scatter", mode:"lines", name:"Median (smoothed rolling)"},
    {x, y: m.medianTrendLine.map(p=>p.y), type:"scatter", mode:"lines", name:"Median trend"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Price (GBP)"},
    legend:{orientation:"h", y:-0.22},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});

  // Mcap chart
  Plotly.newPlot("chartMcap", [
    {x: m.mcap.map(p=>p.x), y: m.mcap.map(p=>p.y), type:"scatter", mode:"lines", name:"Mcap proxy (mean×lots)"},
    {x: m.mcapTrend.map(p=>p.x), y: m.mcapTrend.map(p=>p.y), type:"scatter", mode:"lines", name:"Mcap trend"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Mcap Proxy"},
    legend:{orientation:"h", y:-0.25},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});

  // Concentration chart (annual)
  Plotly.newPlot("chartConc", [
    {x: m.concSeries.map(d=>d.year), y: m.concSeries.map(d=>d.share), type:"scatter", mode:"lines+markers", name:"Top decile value share"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Share", tickformat:".0%"},
    xaxis:{title:"Year", dtick:1},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});
}

function renderRankings(which){
  const rows = Array.from(metricsByArtist.values()).filter(m => m.eligible);

  const keyFn = {
    cagr: (m) => m.meanCagr,
    abs:  (m) => m.absDelta,
    mcap: (m) => m.mcapDelta,
    r2:   (m) => m.r2,
    conc: (m) => m.concDeltaWin
  }[which];

  rows.sort((a,b)=>{
    const av = keyFn(a), bv = keyFn(b);
    if(!Number.isFinite(av) && !Number.isFinite(bv)) return 0;
    if(!Number.isFinite(av)) return 1;
    if(!Number.isFinite(bv)) return -1;
    return bv - av;
  });

  const top = rows.slice(0, 50);
  els.rankBody.innerHTML = top.map((m,i) => `
    <tr>
      <td>${i+1}</td>
      <td><a href="#" data-k="${escapeHtml(m.akey)}">${escapeHtml(m.artistName)}</a></td>
      <td>${fmtPct(m.meanCagr)}</td>
      <td>${fmtPct(m.medianCagr)}</td>
      <td>${fmtPct(m.cagrDivergence)}</td>
      <td>${Number.isFinite(m.ratioShift) ? m.ratioShift.toFixed(2) : "—"}</td>
      <td>${fmtNum(m.absDelta)}</td>
      <td>${fmtNum(m.mcapDelta)}</td>
      <td>${fmtShare(m.concLatest)}</td>
      <td>${fmtShare(m.concDeltaWin)}</td>
      <td>${Number.isFinite(m.r2) ? m.r2.toFixed(2) : "—"}</td>
      <td>${fmtNum(m.lots24)}</td>
      <td>${fmtNum(m.lots12)}</td>
    </tr>
  `).join("");

  els.rankBody.querySelectorAll("a[data-k]").forEach(a=>{
    a.addEventListener("click", (e)=>{
      e.preventDefault();
      const k = e.currentTarget.getAttribute("data-k");
      els.artistSelect.value = k;
      currentArtist = k;
      renderArtist(k);
    });
  });
}

/* ============================
   Events
============================ */
els.file.addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;

  const text = await f.text();
  try{
    lotRows = parseLotCSV(text);
  }catch(err){
    alert(err.message || String(err));
    return;
  }
  if(!lotRows.length){
    alert("No valid lot rows found. Check columns + ValueGBP numeric + MonthYYY = YYYYMM.");
    return;
  }

  buildAggregates();

  els.artistSelect.innerHTML =
    `<option value="">Select artist…</option>` +
    artists.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(k.split("|")[1])}</option>`).join("");
  els.artistSelect.disabled = false;
  els.btnRecalc.disabled = false;
  els.btnTop.disabled = false;

  currentArtist = artists[0];
  els.artistSelect.value = currentArtist;

  recalcAll();
  renderArtist(currentArtist);
});

els.artistSelect.addEventListener("change", ()=>{
  const k = els.artistSelect.value;
  if(!k) return;
  currentArtist = k;
  renderArtist(k);
});

els.btnRecalc.addEventListener("click", ()=>{
  if(!artists.length) return;
  recalcAll();
});

els.btnTop.addEventListener("click", ()=>{
  document.getElementById("rankTable").scrollIntoView({behavior:"smooth", block:"start"});
});

els.tabs.forEach(t=>{
  t.addEventListener("click", ()=>{
    els.tabs.forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    renderRankings(t.getAttribute("data-tab"));
  });
});
</script>
</body>
</html>
