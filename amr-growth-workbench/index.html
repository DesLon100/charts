<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AMR Internal: 5Y Growth Workbench (Mean/Median + Concentration)</title>

  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    :root{
      --bg:#ffffff; --fg:#111; --muted:#666; --card:#f6f6f7; --line:#e5e5e7;
      --btn:#111; --btnfg:#fff; --shadow:0 6px 18px rgba(0,0,0,.08); --radius:14px;
    }
    body{margin:0;padding:14px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:transparent;color:var(--fg);}
    .wrap{max-width:1180px;margin:0 auto;}
    .title{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap;}
    .title h1{font-size:18px;margin:0;}
    .title .sub{color:var(--muted);font-size:12px;}
    .panel{margin-top:12px;background:var(--bg);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px;}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px;}
    input[type="file"]{height:40px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;max-width:340px;}
    select,input[type="number"]{height:40px;padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:#fff;min-width:160px;}
    .btn{height:40px;padding:8px 12px;border-radius:12px;border:1px solid var(--btn);background:var(--btn);color:var(--btnfg);cursor:pointer;font-weight:600;}
    .btn:disabled{opacity:.5;cursor:not-allowed;}
    .grid{display:grid;grid-template-columns:1.35fr .65fr;gap:12px;}
    @media (max-width:980px){.grid{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:10px;}
    .card h3{margin:0 0 6px 0;font-size:13px;}
    .kpis{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;}
    .kpi{background:#fff;border:1px solid var(--line);border-radius:12px;padding:8px 10px;}
    .kpi .lab{font-size:11px;color:var(--muted);}
    .kpi .val{font-size:14px;font-weight:700;margin-top:2px;}
    .note{font-size:12px;color:var(--muted);line-height:1.35;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--line);background:#fff;cursor:pointer;font-weight:600;font-size:12px;}
    .tab.active{border-color:#111;}
    .tableWrap{overflow:auto;border:1px solid var(--line);border-radius:var(--radius);background:#fff;}
    table{border-collapse:collapse;width:100%;min-width:1160px;font-size:12px;}
    th,td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;white-space:nowrap;}
    th{background:#fafafa;position:sticky;top:0;z-index:1;}
    tr:hover td{background:#fbfbff;}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;font-size:11px;color:var(--muted);}
  </style>
</head>

<body>
<div class="wrap">
  <div class="title">
    <h1>AMR Internal: 5-Year Growth Workbench</h1>
    <div class="sub">Lot-level upload → monthly mean/median + lots → trend CAGR + Mcap proxy + concentration</div>
  </div>

  <div class="panel">
    <div class="controls">
      <input id="file" type="file" accept=".csv,text/csv" />
      <select id="artistSelect" disabled>
        <option value="">Upload data first…</option>
      </select>

      <label class="pill">Min lots / 24M</label>
      <input id="minLots24" type="number" value="50" min="0" step="1" />

      <label class="pill">Rolling (months)</label>
      <input id="rollM" type="number" value="12" min="1" step="1" />

      <label class="pill">Extra smooth (months)</label>
      <input id="smoothM" type="number" value="5" min="1" step="1" />

      <label class="pill">Trend window (months)</label>
      <input id="trendM" type="number" value="60" min="12" step="1" />

      <button id="btnRecalc" class="btn" disabled>Recalculate</button>
      <button id="btnTop" class="btn" disabled>Show Top Artists</button>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Monthly Mean & Median Price (Rolling + Smoothed) with Log-Linear Trends</h3>
        <div id="chartPrice" style="height:440px;"></div>
        <div class="note">
          Pipeline: lot-level → monthly mean + monthly median + monthly lots → 12M rolling mean → extra smoothing.
          Trend: OLS on log(series) over the last N months → CAGR + predicted start/end. Mean/median divergence is a concentration flag.
        </div>
      </div>

      <div class="card">
        <h3>KPIs (Selected Artist)</h3>
        <div class="kpis" id="kpis"></div>
        <div style="height:10px;"></div>

        <h3>Market-cap Proxy (Price × Lots)</h3>
        <div id="chartMcap" style="height:230px;"></div>
        <div class="note">Proxy = smoothed rolling mean price × smoothed rolling lots (lots summed over the same rolling window).</div>

        <div style="height:10px;"></div>
        <h3>Concentration (Top Decile Value Share)</h3>
        <div id="chartConc" style="height:230px;"></div>
        <div class="note">
          For each year in the 5Y window: top 10% of lots by price / total annual value. Rising share = trophy concentration.
        </div>
      </div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="cagr">Top by Mean CAGR (trend-based)</div>
      <div class="tab" data-tab="abs">Top by Abs Δ Mean Price (trend-based)</div>
      <div class="tab" data-tab="mcap">Top by Abs Δ Mcap Proxy (trend-based)</div>
      <div class="tab" data-tab="r2">Top by Trend Strength (R²)</div>
      <div class="tab" data-tab="conc">Top by Concentration Increase (5Y)</div>
    </div>

    <div class="card" style="margin-top:10px;">
      <h3>Rankings</h3>
      <div class="tableWrap">
        <table id="rankTable">
          <thead><tr>
            <th>Rank</th>
            <th>Artist</th>
            <th>Mean CAGR</th>
            <th>Median CAGR</th>
            <th>Mean–Median CAGR Δ</th>
            <th>Mean/Median Ratio Shift</th>
            <th>Abs Δ Mean Price</th>
            <th>Abs Δ Mcap</th>
            <th>Top-Decile Share (Latest Yr)</th>
            <th>Δ Top-Decile Share (5Y)</th>
            <th>R² (Mean)</th>
            <th>Lots (last 24M)</th>
            <th>Lots (last 12M)</th>
          </tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="note" style="margin-top:8px;">
        Eligibility rule: at least <span id="minLotsEcho">50</span> lots in the last 24 months.
      </div>
    </div>
  </div>
</div>

<script>
/* ============================
   Utilities
============================ */
function parseNumberLoose(v){
  if(v === null || v === undefined) return NaN;
  const s = String(v).trim().replace(/[£$€]/g,'').replace(/,/g,'').replace(/\s+/g,'');
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}
function splitCSVLine(line){
  const out = [];
  let cur = "", inQ = false;
  for(let i=0;i<line.length;i++){
    const ch = line[i];
    if(ch === '"'){
      if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    }else if(ch === "," && !inQ){
      out.push(cur); cur = "";
    }else{
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function ymToDate(yyyymm){
  const s = String(yyyymm).trim();
  if(!/^\d{6}$/.test(s)) return null;
  const y = Number(s.slice(0,4));
  const m = Number(s.slice(4,6));
  if(!(y>=1900 && m>=1 && m<=12)) return null;
  return new Date(Date.UTC(y, m-1, 1));
}
function monthDiff(a, b){
  return (b.getUTCFullYear()-a.getUTCFullYear())*12 + (b.getUTCMonth()-a.getUTCMonth());
}
function rollingMean(arr, win){
  const out = [], q = [];
  let sum = 0, cnt = 0;
  for(let i=0;i<arr.length;i++){
    const y = arr[i].y;
    q.push(y);
    if(Number.isFinite(y)){ sum += y; cnt += 1; }
    if(q.length > win){
      const old = q.shift();
      if(Number.isFinite(old)){ sum -= old; cnt -= 1; }
    }
    const val = (q.length === win && cnt > 0) ? (sum / cnt) : NaN;
    out.push({x: arr[i].x, y: val});
  }
  return out;
}
function rollingSum(arr, win){
  const out = [], q = [];
  let sum = 0;
  for(let i=0;i<arr.length;i++){
    const y = Number.isFinite(arr[i].y) ? arr[i].y : 0;
    q.push(y);
    sum += y;
    if(q.length > win) sum -= q.shift();
    out.push({x: arr[i].x, y: (q.length===win)?sum:NaN});
  }
  return out;
}
function ols(x, y){
  const n = x.length;
  if(n < 3) return null;
  let sx=0, sy=0, sxx=0, sxy=0;
  for(let i=0;i<n;i++){ sx+=x[i]; sy+=y[i]; sxx+=x[i]*x[i]; sxy+=x[i]*y[i]; }
  const denom = (n*sxx - sx*sx);
  if(Math.abs(denom) < 1e-12) return null;
  const b = (n*sxy - sx*sy)/denom;
  const a = (sy - b*sx)/n;

  const yhat = x.map(t => a + b*t);
  const ybar = sy/n;
  let ssTot=0, ssRes=0;
  for(let i=0;i<n;i++){
    ssTot += (y[i]-ybar)*(y[i]-ybar);
    ssRes += (y[i]-yhat[i])*(y[i]-yhat[i]);
  }
  const r2 = ssTot > 0 ? 1 - (ssRes/ssTot) : NaN;
  return {a,b,r2};
}
function fmtPct(v){ return Number.isFinite(v) ? (v*100).toFixed(1)+"%" : "—"; }
function fmtPct2(v){ return Number.isFinite(v) ? (v*100).toFixed(2)+"%" : "—"; }
function fmtShare(v){ return Number.isFinite(v) ? (v*100).toFixed(1)+"%" : "—"; }
function fmtNum(v){
  if(!Number.isFinite(v)) return "—";
  const abs = Math.abs(v);
  if(abs >= 1e9) return (v/1e9).toFixed(2)+"B";
  if(abs >= 1e6) return (v/1e6).toFixed(2)+"M";
  if(abs >= 1e3) return (v/1e3).toFixed(2)+"k";
  return Math.round(v).toString();
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}

/* ============================
   State
============================ */
let lotRows = [];                  // {id,name,date,price}
let monthlyByArtist = new Map();   // key "id|name" -> [{date, meanPrice, medianPrice, lots}]
let annualByArtist = new Map();    // key -> Map(year -> prices[])
let artists = [];
let metricsByArtist = new Map();
let currentArtist = null;

const els = {
  file: document.getElementById("file"),
  artistSelect: document.getElementById("artistSelect"),
  minLots24: document.getElementById("minLots24"),
  rollM: document.getElementById("rollM"),
  smoothM: document.getElementById("smoothM"),
  trendM: document.getElementById("trendM"),
  btnRecalc: document.getElementById("btnRecalc"),
  btnTop: document.getElementById("btnTop"),
  kpis: document.getElementById("kpis"),
  rankBody: document.querySelector("#rankTable tbody"),
  tabs: Array.from(document.querySelectorAll(".tab")),
  minLotsEcho: document.getElementById("minLotsEcho"),
};

/* ============================
   Parse lot-level CSV
============================ */
function parseLotCSV(text){
  const lines = text.replace(/\r/g,'').split("\n").filter(l => l.trim().length);
  if(lines.length < 2) return [];

  const headers = splitCSVLine(lines[0]).map(h => h.trim());
  const idx = (name) => headers.findIndex(h => h.toLowerCase() === name.toLowerCase());

  const iID = idx("ArtistID");
  const iName = idx("ArtistName");
  const iMonth = idx("MonthYYY");
  const iVal = idx("ValueGBP");

  if(iID < 0 || iName < 0 || iMonth < 0 || iVal < 0){
    throw new Error("CSV must include headers: ArtistID, ArtistName, MonthYYY, ValueGBP");
  }

  const rows = [];
  for(let i=1;i<lines.length;i++){
    const cells = splitCSVLine(lines[i]);
    const id = (cells[iID] ?? "").trim();
    const name = (cells[iName] ?? "").trim();
    const dt = ymToDate(cells[iMonth]);
    const price = parseNumberLoose(cells[iVal]);
    if(!id || !name || !dt || !Number.isFinite(price) || price <= 0) continue;
    rows.push({id, name, date: dt, price});
  }
  return rows;
}

/* ============================
   Aggregate: Monthly mean/median/lots + Annual price lists
============================ */
function buildAggregates(){
  monthlyByArtist = new Map();
  annualByArtist = new Map();

  // Monthly aggregation holder: artistKey -> monthTime -> {sum,cnt,prices[]}
  const monthMap = new Map();

  let minD = null, maxD = null;

  for(const r of lotRows){
    if(!minD || r.date < minD) minD = r.date;
    if(!maxD || r.date > maxD) maxD = r.date;

    const akey = `${r.id}|${r.name}`;
    const mkey = r.date.getTime();

    if(!monthMap.has(akey)) monthMap.set(akey, new Map());
    const mm = monthMap.get(akey);
    if(!mm.has(mkey)) mm.set(mkey, {sum:0, cnt:0, prices:[]});
    const agg = mm.get(mkey);
    agg.sum += r.price;
    agg.cnt += 1;
    agg.prices.push(r.price);

    // annual list for concentration
    const yr = r.date.getUTCFullYear();
    if(!annualByArtist.has(akey)) annualByArtist.set(akey, new Map());
    const am = annualByArtist.get(akey);
    if(!am.has(yr)) am.set(yr, []);
    am.get(yr).push(r.price);
  }

  // Global monthly timeline (ensures aligned rolling windows)
  const timeline = [];
  let cur = new Date(Date.UTC(minD.getUTCFullYear(), minD.getUTCMonth(), 1));
  const end = new Date(Date.UTC(maxD.getUTCFullYear(), maxD.getUTCMonth(), 1));
  while(cur <= end){
    timeline.push(new Date(cur));
    cur = new Date(Date.UTC(cur.getUTCFullYear(), cur.getUTCMonth()+1, 1));
  }

  for(const [akey, mm] of monthMap.entries()){
    const series = [];
    for(const dt of timeline){
      const k = dt.getTime();
      const agg = mm.get(k);
      if(agg){
        const prices = agg.prices.slice().sort((a,b)=>a-b);
        const mid = Math.floor(prices.length/2);
        const median = (prices.length % 2) ? prices[mid] : (prices[mid-1] + prices[mid]) / 2;
        series.push({date: dt, meanPrice: agg.sum / agg.cnt, medianPrice: median, lots: agg.cnt});
      }else{
        series.push({date: dt, meanPrice: NaN, medianPrice: NaN, lots: 0});
      }
    }
    monthlyByArtist.set(akey, series);
  }

  artists = Array.from(monthlyByArtist.keys()).sort((a,b)=>{
    const an = a.split("|")[1].toLowerCase();
    const bn = b.split("|")[1].toLowerCase();
    return an.localeCompare(bn);
  });
}

/* ============================
   Concentration: Top Decile Value Share per year
   (top 10% lots by price / total annual value)
============================ */
function topDecileShare(prices){
  // prices: number[] (positive)
  if(!prices || prices.length < 10) return NaN; // too few lots to define decile meaningfully
  const sorted = prices.slice().sort((a,b)=>a-b);
  const n = sorted.length;
  const k = Math.max(1, Math.ceil(n * 0.10)); // top 10%
  let total = 0;
  for(const v of sorted) total += v;
  if(total <= 0) return NaN;
  let top = 0;
  for(let i=n-k;i<n;i++) top += sorted[i];
  return top / total; // 0..1
}

/* ============================
   Metrics per artist
============================ */
function computeMetrics(akey, params){
  const series = monthlyByArtist.get(akey);
  if(!series || series.length < 24) return null;

  const roll = params.rollM;
  const smooth = params.smoothM;
  const trendWin = params.trendM;

  const meanArr = series.map(d => ({x:d.date, y:d.meanPrice}));
  const medianArr = series.map(d => ({x:d.date, y:d.medianPrice}));
  const lotsMonthlyArr = series.map(d => ({x:d.date, y:d.lots}));

  // Mean pipeline
  const rollMean = rollingMean(meanArr, roll);
  const smoothMean = rollingMean(rollMean, smooth);

  // Median pipeline
  const rollMedian = rollingMean(medianArr, roll);
  const smoothMedian = rollingMean(rollMedian, smooth);

  // Rolling lots (sum over months) + extra smooth
  const rollLots = rollingSum(lotsMonthlyArr, roll);
  const smoothLots = rollingMean(rollLots, smooth);

  // Mcap proxy
  const mcap = smoothMean.map((pt,i)=>{
    const L = smoothLots[i]?.y;
    const y = (Number.isFinite(pt.y) && Number.isFinite(L)) ? (pt.y * L) : NaN;
    return {x: pt.x, y};
  });

  // Lots last 24/12 months (raw)
  const lastDate = series[series.length-1].date;
  const last24Start = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-23, 1));
  const last12Start = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-11, 1));
  let lots24=0, lots12=0;
  for(const d of series){
    if(d.date >= last24Start) lots24 += d.lots;
    if(d.date >= last12Start) lots12 += d.lots;
  }
  const eligible = lots24 >= params.minLots24;

  // Trend window start
  const startTrend = new Date(Date.UTC(lastDate.getUTCFullYear(), lastDate.getUTCMonth()-(trendWin-1), 1));

  // ===== Mean trend (log-linear)
  const x=[], y=[];
  for(const pt of smoothMean){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    x.push(monthDiff(startTrend, pt.x));
    y.push(Math.log(pt.y));
  }
  const fit = ols(x,y);

  let meanCagr=NaN, r2=NaN, meanStart=NaN, meanEnd=NaN, absDelta=NaN;
  const meanTrendLine = smoothMean.map(pt => ({x:pt.x, y:NaN}));

  if(fit){
    r2 = fit.r2;
    meanCagr = Math.exp(fit.b * 12) - 1;
    const t0=0, t1=trendWin-1;
    meanStart = Math.exp(fit.a + fit.b*t0);
    meanEnd   = Math.exp(fit.a + fit.b*t1);
    absDelta  = meanEnd - meanStart;

    for(let i=0;i<meanTrendLine.length;i++){
      const dt = meanTrendLine[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      meanTrendLine[i].y = Math.exp(fit.a + fit.b*t);
    }
  }

  // ===== Median trend (log-linear)
  const xm=[], ym=[];
  for(const pt of smoothMedian){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    xm.push(monthDiff(startTrend, pt.x));
    ym.push(Math.log(pt.y));
  }
  const fitMed = ols(xm, ym);

  let medianCagr=NaN, medianStart=NaN, medianEnd=NaN;
  const medianTrendLine = smoothMedian.map(pt => ({x:pt.x, y:NaN}));

  if(fitMed){
    medianCagr = Math.exp(fitMed.b * 12) - 1;
    const t0=0, t1=trendWin-1;
    medianStart = Math.exp(fitMed.a + fitMed.b*t0);
    medianEnd   = Math.exp(fitMed.a + fitMed.b*t1);

    for(let i=0;i<medianTrendLine.length;i++){
      const dt = medianTrendLine[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      medianTrendLine[i].y = Math.exp(fitMed.a + fitMed.b*t);
    }
  }

  // ===== Divergence flags
  const cagrDivergence = (Number.isFinite(meanCagr) && Number.isFinite(medianCagr)) ? (meanCagr - medianCagr) : NaN;

  let ratioStart=NaN, ratioEnd=NaN, ratioShift=NaN;
  if(Number.isFinite(meanStart) && Number.isFinite(medianStart) && Number.isFinite(meanEnd) && Number.isFinite(medianEnd) && medianStart>0 && medianEnd>0){
    ratioStart = meanStart / medianStart;
    ratioEnd = meanEnd / medianEnd;
    ratioShift = ratioEnd - ratioStart;
  }

  // ===== Mcap trend delta (log-linear on mcap)
  const xk=[], yk=[];
  for(const pt of mcap){
    if(pt.x < startTrend) continue;
    if(!Number.isFinite(pt.y) || pt.y <= 0) continue;
    xk.push(monthDiff(startTrend, pt.x));
    yk.push(Math.log(pt.y));
  }
  const fitM = ols(xk, yk);
  let mcapDelta=NaN;
  const mcapTrend = mcap.map(pt => ({x:pt.x, y:NaN}));
  if(fitM){
    const t0=0, t1=trendWin-1;
    const m0 = Math.exp(fitM.a + fitM.b*t0);
    const m1 = Math.exp(fitM.a + fitM.b*t1);
    mcapDelta = m1 - m0;

    for(let i=0;i<mcapTrend.length;i++){
      const dt = mcapTrend[i].x;
      if(dt < startTrend) continue;
      const t = monthDiff(startTrend, dt);
      if(t < 0 || t > t1) continue;
      mcapTrend[i].y = Math.exp(fitM.a + fitM.b*t);
    }
  }

  // ===== Concentration (annual top-decile share) in window years
  const startYear = startTrend.getUTCFullYear();
  const endYear = lastDate.getUTCFullYear();
  const annualMap = annualByArtist.get(akey) || new Map();

  const concSeries = []; // [{year, share}]
  for(let yr=startYear; yr<=endYear; yr++){
    const prices = annualMap.get(yr);
    const share = topDecileShare(prices);
    if(Number.isFinite(share)) concSeries.push({year: yr, share});
  }

  // latest & 5Y change: use first/last available within window
  let concLatest = NaN, concDelta5y = NaN;
  if(concSeries.length >= 2){
    concLatest = concSeries[concSeries.length-1].share;
    concDelta5y = concSeries[concSeries.length-1].share - concSeries[0].share;
  } else if(concSeries.length === 1){
    concLatest = concSeries[0].share;
  }

  return {
    akey,
    artistName: akey.split("|")[1],
    eligible,
    lots24,
    lots12,

    smoothMean,
    meanTrendLine,
    smoothMedian,
    medianTrendLine,

    meanCagr,
    medianCagr,
    cagrDivergence,
    ratioShift,

    absDelta,
    r2,

    mcap,
    mcapTrend,
    mcapDelta,

    concSeries,
    concLatest,
    concDelta5y
  };
}

function recalcAll(){
  const params = {
    minLots24: Math.max(0, Number(els.minLots24.value || 0)),
    rollM: Math.max(1, Number(els.rollM.value || 12)),
    smoothM: Math.max(1, Number(els.smoothM.value || 5)),
    trendM: Math.max(12, Number(els.trendM.value || 60))
  };
  els.minLotsEcho.textContent = String(params.minLots24);

  metricsByArtist = new Map();
  for(const a of artists){
    const m = computeMetrics(a, params);
    if(m) metricsByArtist.set(a, m);
  }

  if(currentArtist && metricsByArtist.has(currentArtist)) renderArtist(currentArtist);
  renderRankings("cagr");
}

/* ============================
   Rendering
============================ */
function renderArtist(akey){
  const m = metricsByArtist.get(akey);
  if(!m) return;

  const kpis = [
    {lab:"Mean CAGR (trend-based, 5Y)", val: fmtPct(m.meanCagr)},
    {lab:"Median CAGR (trend-based, 5Y)", val: fmtPct(m.medianCagr)},
    {lab:"Mean–Median CAGR Δ", val: fmtPct(m.cagrDivergence)},
    {lab:"Mean/Median Ratio Shift (5Y)", val: Number.isFinite(m.ratioShift) ? m.ratioShift.toFixed(2) : "—"},
    {lab:"Abs Δ Mean Price (trend-based)", val: fmtNum(m.absDelta)},
    {lab:"Abs Δ Mcap (trend-based)", val: fmtNum(m.mcapDelta)},
    {lab:"Top-Decile Share (Latest Yr)", val: fmtShare(m.concLatest)},
    {lab:"Δ Top-Decile Share (5Y)", val: fmtShare(m.concDelta5y)},
    {lab:"Trend strength (R², mean)", val: Number.isFinite(m.r2) ? m.r2.toFixed(2) : "—"},
    {lab:"Lots (last 24M)", val: fmtNum(m.lots24)},
    {lab:"Lots (last 12M)", val: fmtNum(m.lots12)},
    {lab:"Eligibility (min lots)", val: m.eligible ? "Yes" : "No"},
  ];
  els.kpis.innerHTML = kpis.map(k => `
    <div class="kpi"><div class="lab">${k.lab}</div><div class="val">${k.val}</div></div>
  `).join("");

  // Price chart: mean + mean trend + median + median trend
  const x = m.smoothMean.map(p => p.x);
  const yMean = m.smoothMean.map(p => p.y);
  const yMeanT = m.meanTrendLine.map(p => p.y);

  const yMed = m.smoothMedian.map(p => p.y);
  const yMedT = m.medianTrendLine.map(p => p.y);

  Plotly.newPlot("chartPrice", [
    {x, y: yMean, type:"scatter", mode:"lines", name:"Mean (smoothed rolling)"},
    {x, y: yMeanT, type:"scatter", mode:"lines", name:"Mean trend (log-linear → level)"},
    {x, y: yMed, type:"scatter", mode:"lines", name:"Median (smoothed rolling)"},
    {x, y: yMedT, type:"scatter", mode:"lines", name:"Median trend (log-linear → level)"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Price (GBP)"},
    legend:{orientation:"h", y:-0.22},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});

  // Mcap chart
  const xm = m.mcap.map(p => p.x);
  const ym = m.mcap.map(p => p.y);
  const ymt = m.mcapTrend.map(p => p.y);

  Plotly.newPlot("chartMcap", [
    {x:xm, y:ym, type:"scatter", mode:"lines", name:"Mcap proxy (mean×lots)"},
    {x:xm, y:ymt, type:"scatter", mode:"lines", name:"Mcap trend"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Mcap Proxy"},
    legend:{orientation:"h", y:-0.25},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});

  // Concentration chart (annual)
  const xc = m.concSeries.map(d => d.year);
  const yc = m.concSeries.map(d => d.share);

  Plotly.newPlot("chartConc", [
    {x:xc, y:yc, type:"scatter", mode:"lines+markers", name:"Top decile value share"},
  ], {
    margin:{l:50,r:20,t:10,b:40},
    yaxis:{title:"Share", tickformat:".0%"},
    xaxis:{title:"Year", dtick:1},
    hovermode:"x unified",
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)"
  }, {displayModeBar:false, responsive:true});
}

function renderRankings(which){
  const rows = [];
  for(const m of metricsByArtist.values()){
    if(!m.eligible) continue;
    rows.push(m);
  }

  const keyFn = {
    cagr: (m) => m.meanCagr,
    abs:  (m) => m.absDelta,
    mcap: (m) => m.mcapDelta,
    r2:   (m) => m.r2,
    conc: (m) => m.concDelta5y
  }[which];

  rows.sort((a,b)=>{
    const av = keyFn(a), bv = keyFn(b);
    if(!Number.isFinite(av) && !Number.isFinite(bv)) return 0;
    if(!Number.isFinite(av)) return 1;
    if(!Number.isFinite(bv)) return -1;
    return bv - av;
  });

  const top = rows.slice(0, 50);
  els.rankBody.innerHTML = top.map((m,i) => `
    <tr>
      <td>${i+1}</td>
      <td><a href="#" data-k="${escapeHtml(m.akey)}">${escapeHtml(m.artistName)}</a></td>
      <td>${fmtPct(m.meanCagr)}</td>
      <td>${fmtPct(m.medianCagr)}</td>
      <td>${fmtPct(m.cagrDivergence)}</td>
      <td>${Number.isFinite(m.ratioShift) ? m.ratioShift.toFixed(2) : "—"}</td>
      <td>${fmtNum(m.absDelta)}</td>
      <td>${fmtNum(m.mcapDelta)}</td>
      <td>${fmtShare(m.concLatest)}</td>
      <td>${fmtShare(m.concDelta5y)}</td>
      <td>${Number.isFinite(m.r2) ? m.r2.toFixed(2) : "—"}</td>
      <td>${fmtNum(m.lots24)}</td>
      <td>${fmtNum(m.lots12)}</td>
    </tr>
  `).join("");

  els.rankBody.querySelectorAll("a[data-k]").forEach(a=>{
    a.addEventListener("click", (e)=>{
      e.preventDefault();
      const k = e.currentTarget.getAttribute("data-k");
      els.artistSelect.value = k;
      currentArtist = k;
      renderArtist(k);
    });
  });
}

/* ============================
   Events
============================ */
els.file.addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;

  const text = await f.text();
  try{
    lotRows = parseLotCSV(text);
  }catch(err){
    alert(err.message || String(err));
    return;
  }
  if(!lotRows.length){
    alert("No valid lot rows found. Check columns + ValueGBP numeric + MonthYYY = YYYYMM.");
    return;
  }

  buildAggregates();

  els.artistSelect.innerHTML =
    `<option value="">Select artist…</option>` +
    artists.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(k.split("|")[1])}</option>`).join("");
  els.artistSelect.disabled = false;
  els.btnRecalc.disabled = false;
  els.btnTop.disabled = false;

  currentArtist = artists[0];
  els.artistSelect.value = currentArtist;

  recalcAll();
  renderArtist(currentArtist);
});

els.artistSelect.addEventListener("change", ()=>{
  const k = els.artistSelect.value;
  if(!k) return;
  currentArtist = k;
  renderArtist(k);
});

els.btnRecalc.addEventListener("click", ()=>{
  if(!artists.length) return;
  recalcAll();
});

els.btnTop.addEventListener("click", ()=>{
  document.getElementById("rankTable").scrollIntoView({behavior:"smooth", block:"start"});
});

els.tabs.forEach(t=>{
  t.addEventListener("click", ()=>{
    els.tabs.forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    renderRankings(t.getAttribute("data-tab"));
  });
});
</script>
</body>
</html>
