<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Monthly Moving Average</title>

<style>
  body{
    margin:0;
    padding:14px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:transparent;
  }
  .wrap{ max-width:645px; }

  .boot{
    background:#fffbcc;
    border:1px solid #e6d56a;
    border-radius:10px;
    padding:10px 12px;
    margin-bottom:10px;
    font-size:13px;
  }

  .controls{
    display:flex;
    gap:10px;
    margin-bottom:10px;
    flex-wrap:wrap;
    align-items:center;
  }

  input[type="file"]{ height:40px; background:#fff; }
  select{
    height:40px;
    border-radius:10px;
    border:1px solid #ccc;
    background:#fff;
    padding:0 12px;
    font-size:14px;
  }

  #chart{ width:100%; height:360px; }

  #status{
    margin-top:8px;
    font-size:12px;
    background:#fff;
    padding:8px 10px;
    border:1px solid #ddd;
    border-radius:10px;
    display:block;          /* IMPORTANT: always visible until chart draws */
    white-space:pre-wrap;
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="boot">HTML LOADED ✅ (if you can see this, you are viewing the correct file)</div>

  <div class="controls">
    <input type="file" id="fileInput" accept=".csv">
    <select id="windowSelect">
      <option value="12">12-month avg</option>
      <option value="24">24-month avg</option>
      <option value="36">36-month avg</option>
    </select>
  </div>

  <div id="chart"></div>
  <div id="status">Starting…</div>
</div>

<script>
  const fileInput = document.getElementById("fileInput");
  const windowSelect = document.getElementById("windowSelect");
  const statusEl = document.getElementById("status");

  function status(msg){ statusEl.textContent = msg; }
  function clearStatus(){ statusEl.textContent = ""; statusEl.style.display = "none"; }

  window.addEventListener("error", (e) => {
    status("JS error:\n" + (e.message || e.type) + "\n" + (e.filename || "") + ":" + (e.lineno || ""));
  });
  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e && e.reason && (e.reason.message || String(e.reason))) || "Unknown rejection";
    status("Unhandled promise rejection:\n" + msg);
  });

  // ---- Plotly loader with fallback CDNs ----
  async function loadScript(src){
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.async = true;
      s.onload = resolve;
      s.onerror = () => reject(new Error("Failed to load: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensurePlotly(){
    if (typeof Plotly !== "undefined") return true;

    const cdns = [
      "https://cdn.plot.ly/plotly-2.35.2.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.35.2/plotly.min.js",
      "https://unpkg.com/plotly.js-dist-min@2.35.2/plotly.min.js"
    ];

    for (const url of cdns){
      try{
        status("Loading Plotly…\n" + url);
        await loadScript(url);
        if (typeof Plotly !== "undefined"){
          status("Plotly loaded ✅");
          return true;
        }
      } catch (e){
        // try next
      }
    }

    status(
      "Plotly failed to load ❌\n" +
      "This is usually caused by an ad-blocker, strict corporate network policy, or blocked CDNs.\n" +
      "Try disabling blockers for this page, or use a different network."
    );
    return false;
  }

  // Call immediately
  ensurePlotly();

  // ---- Data + chart code ----
  let monthlyCalendar = [];

  fileInput.addEventListener("change", async () => {
    const file = fileInput.files?.[0];
    if (!file) return;

    const ok = await ensurePlotly();
    if (!ok) return;

    try {
      status("Reading CSV…");
      const text = await file.text();
      const rows = parseCSV(text);

      monthlyCalendar = buildMonthlyCalendar(rows);

      if (!monthlyCalendar.length) {
        Plotly.purge("chart");
        status("No valid rows found.\nExpected CSV columns: Month (YYYYMM), Value.");
        return;
      }

      status(
        `CSV loaded ✅\n` +
        `Raw rows: ${rows.length}\n` +
        `Calendar months: ${monthlyCalendar.length} (missing months filled with 0)\n` +
        `Rendering…`
      );

      draw();

    } catch (err) {
      console.error(err);
      Plotly.purge("chart");
      status("Error reading CSV:\n" + (err?.message || String(err)));
    }
  });

  windowSelect.addEventListener("change", async () => {
    if (!monthlyCalendar.length) return;
    const ok = await ensurePlotly();
    if (!ok) return;
    draw();
  });

  function parseCSV(text){
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++){
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
      if (ch === '"') { inQuotes = !inQuotes; continue; }

      if (ch === "," && !inQuotes) { row.push(cur); cur = ""; continue; }

      if ((ch === "\n" || ch === "\r") && !inQuotes){
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(c => String(c).trim() !== "")) rows.push(row);
        row = [];
        continue;
      }
      cur += ch;
    }

    row.push(cur);
    if (row.some(c => String(c).trim() !== "")) rows.push(row);

    if (rows.length && /month/i.test(String(rows[0][0] || ""))) rows.shift();
    return rows;
  }

  function toNumber(v){
    if (typeof v === "number") return v;
    const s = String(v ?? "").trim();
    if (!s) return NaN;
    const cleaned = s.replace(/£/g, "").replace(/\s/g, "").replace(/,/g, "");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : NaN;
  }

  function parseYYYYMM(v){
    const s = String(v ?? "").trim();
    if (!s) return null;
    const digits = s.replace(/\D/g, "");
    if (digits.length < 6) return null;

    const y = Number(digits.slice(0, 4));
    const m = Number(digits.slice(4, 6));
    if (!Number.isInteger(y) || !Number.isInteger(m) || m < 1 || m > 12) return null;

    return new Date(Date.UTC(y, m - 1, 1));
  }

  function addMonthsUTC(dateUTC, n){
    return new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth() + n, 1));
  }

  function buildMonthlyCalendar(rows){
    const byMonth = new Map();

    for (const r of rows){
      if (!Array.isArray(r) || r.length < 2) continue;
      const d = parseYYYYMM(r[0]);
      const v = toNumber(r[1]);
      if (!d || !isFinite(v)) continue;

      const key = `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,"0")}`;
      const cur = byMonth.get(key) || { sum: 0, n: 0, date: d };
      cur.sum += v;
      cur.n += 1;
      byMonth.set(key, cur);
    }

    if (byMonth.size === 0) return [];

    const monthDates = Array.from(byMonth.values()).map(x => x.date).sort((a,b) => a - b);
    const minMonth = monthDates[0];
    const maxMonth = monthDates[monthDates.length - 1];

    const out = [];
    for (let d = new Date(minMonth); d <= maxMonth; d = addMonthsUTC(d, 1)){
      const key = `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,"0")}`;
      const agg = byMonth.get(key);
      const value = agg ? (agg.sum / agg.n) : 0;
      out.push({ date: new Date(d), value });
    }
    return out;
  }

  function trailingAvgStrictCalendar(data, n){
    const out = new Array(data.length);
    let runningSum = 0;

    for (let i = 0; i < data.length; i++){
      runningSum += data[i].value;
      if (i >= n) runningSum -= data[i - n].value;

      out[i] = {
        date: data[i].date,
        value: (i < n - 1) ? null : (runningSum / n)
      };
    }
    return out;
  }

  function trailingAvgStrictOnSeries(series, k){
    const out = new Array(series.length);
    let runningSum = 0;
    let validCount = 0;
    const q = [];

    for (let i = 0; i < series.length; i++){
      const v = series[i].value;
      q.push(v);

      if (v !== null && Number.isFinite(v)){
        runningSum += v;
        validCount += 1;
      }

      if (q.length > k){
        const old = q.shift();
        if (old !== null && Number.isFinite(old)){
          runningSum -= old;
          validCount -= 1;
        }
      }

      out[i] = {
        date: series[i].date,
        value: (q.length < k || validCount < k) ? null : (runningSum / k)
      };
    }
    return out;
  }

  function anyNonNull(series){
    return series.some(d => d.value !== null && Number.isFinite(d.value));
  }

  function draw(){
    const n = Number(windowSelect.value);

    const ma = trailingAvgStrictCalendar(monthlyCalendar, n);
    const maSmoothed = trailingAvgStrictOnSeries(ma, 3);

    const hasBase = anyNonNull(ma);
    const hasSmooth = anyNonNull(maSmoothed);

    if (!hasBase){
      Plotly.purge("chart");
      status(
        `Not enough data for ${n}-month rolling average.\n` +
        `Calendar months available: ${monthlyCalendar.length}\n` +
        `Need at least: ${n}`
      );
      return;
    }

    if (!hasSmooth){
      status(
        `Base MA is available, but 3× smoothing needs more months.\n` +
        `For ${n}-month + 3× smoothing you need at least: ${n + 2} months.\n` +
        `You have: ${monthlyCalendar.length}\n\n` +
        `Showing base MA only.`
      );
    }

    const traces = [];

    if (hasSmooth){
      traces.push({
        x: maSmoothed.map(d => d.date),
        y: maSmoothed.map(d => d.value),
        type: "scatter",
        mode: "lines",
        line: { width: 2 },
        name: `${n}-month avg (3× smoothed)`
      });
    }

    traces.push({
      x: ma.map(d => d.date),
      y: ma.map(d => d.value),
      type: "scatter",
      mode: "lines",
      line: { width: 1, dash: "dot" },
      name: `${n}-month avg`
    });

    Plotly.newPlot("chart", traces, {
      paper_bgcolor: "rgba(0,0,0,0)",
      plot_bgcolor: "rgba(0,0,0,0)",
      margin: { l: 75, r: 10, t: 10, b: 45 },
      yaxis: {
        title: "GBP",
        tickprefix: "£",
        tickformat: "~s",
        zeroline: false
      },
      xaxis: {
        type: "date",
        tickformat: "%Y",
        dtick: "M60",
        tick0: "1975-01-01",
        hoverformat: "%Y-%m"
      }
    }, {
      displayModeBar: false,
      responsive: true
    });

    // Only clear status once we successfully draw a chart
    if (hasSmooth) clearStatus();
  }
</script>

</body>
</html>
