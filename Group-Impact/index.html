<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Group Index + Contributors (UMV 12M, LOCF, Rebase)</title>

  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    body{
      margin:0;
      padding:14px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:transparent;
      color:#111;
    }
    .wrap{max-width:980px;margin:0 auto;}
    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:10px;
    }
    input[type="file"]{
      height:40px;
      padding:6px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      background:#fff;
    }
    button{
      height:40px;
      padding:0 12px;
      border:1px solid #ddd;
      border-radius:10px;
      background:#fff;
      cursor:pointer;
    }
    button:hover{border-color:#bbb;}
    .meta{
      font-size:13px;
      color:#444;
      margin:6px 0 14px;
      line-height:1.35;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 900px){
      .grid{grid-template-columns: 2fr 1fr;}
    }
    #chart{
      border:1px solid #eee;
      border-radius:14px;
      padding:6px;
      background:#fff;
    }
    .panel{
      border:1px solid #eee;
      border-radius:14px;
      padding:12px;
      background:#fff;
    }
    .panel h3{
      margin:0 0 10px;
      font-size:14px;
    }
    .small{
      font-size:12px;
      color:#555;
      margin:0 0 10px;
      line-height:1.35;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
    }
    th, td{
      padding:8px 6px;
      border-bottom:1px solid #f0f0f0;
      text-align:left;
    }
    th{font-size:12px;color:#666;font-weight:600;}
    .right{text-align:right;}
    .muted{color:#777;}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border:1px solid #eee;
      border-radius:999px;
      font-size:12px;
      color:#444;
      background:#fafafa;
      margin-left:6px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="controls">
      <input id="file" type="file" accept=".csv,text/csv" />
      <button id="btnContrib" disabled>Show contributors (latest month)</button>
      <button id="btnReset" disabled>Reset</button>
    </div>

    <div class="meta" id="meta">
      Upload a CSV exported from SQL with columns: <b>ArtistID</b>, <b>MonthYYYYMM</b>, <b>ValueGBP</b>.
      This builds a pooled group index using: monthly average → LOCF → 12M rolling UMV → rebased to 1000 at 197601.
    </div>

    <div class="grid">
      <div id="chart"></div>
      <div class="panel">
        <h3>
          Contributors
          <span class="pill" id="pillMonth">—</span>
        </h3>
        <p class="small">
          v1 ranks artists by the absolute change in the <i>latest month’s</i> group index level when that artist’s datapoints are removed
          (fast leave-one-out on monthly pooled averages before LOCF + UMV).
        </p>
        <div id="contrib"></div>
      </div>
    </div>
  </div>

<script>
/** ---------------------------
 *  Utilities: parsing + months
 *  ---------------------------
 */

function parseCSV(text){
  // Minimal CSV parser (handles simple comma-separated numeric fields).
  // Expects header row.
  const lines = text.replace(/\r/g,'').split('\n').filter(l=>l.trim().length);
  if(lines.length < 2) throw new Error("CSV looks empty.");
  const headers = lines[0].split(',').map(h=>h.trim());
  const idxArtist = headers.findIndex(h => /^artistid$/i.test(h));
  const idxMonth   = headers.findIndex(h => /^monthyyyymm$/i.test(h) || /^month$/i.test(h));
  const idxValue   = headers.findIndex(h => /^valuegbp$/i.test(h) || /^data$/i.test(h));
  if(idxArtist === -1 || idxMonth === -1 || idxValue === -1){
    throw new Error("CSV must include headers: ArtistID, MonthYYYYMM (or Month), ValueGBP (or data).");
  }
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const parts = lines[i].split(',');
    if(parts.length < Math.max(idxArtist, idxMonth, idxValue)+1) continue;
    const artist = parseInt(parts[idxArtist],10);
    const month = parseInt(parts[idxMonth],10);
    const value = parseFloat(parts[idxValue]);
    if(!Number.isFinite(artist) || !Number.isFinite(month) || !Number.isFinite(value)) continue;
    rows.push({artist, month, value});
  }
  return rows;
}

function monthToDate(monthYYYYMM){
  const y = Math.floor(monthYYYYMM/100);
  const m = (monthYYYYMM % 100) - 1; // 0-index
  return new Date(Date.UTC(y, m, 1));
}

function nextMonth(monthYYYYMM){
  const y = Math.floor(monthYYYYMM/100);
  const m = monthYYYYMM % 100;
  if(m === 12) return (y+1)*100 + 1;
  return y*100 + (m+1);
}

function buildMonthSpine(minMonth, maxMonth){
  const spine = [];
  let cur = minMonth;
  while(cur <= maxMonth){
    spine.push(cur);
    cur = nextMonth(cur);
  }
  return spine;
}

function locfFill(spine, monthToValue){
  // Returns array aligned to spine. Fills missing with last seen.
  const out = new Array(spine.length).fill(null);
  let last = null;
  for(let i=0;i<spine.length;i++){
    const m = spine[i];
    if(monthToValue.has(m)){
      last = monthToValue.get(m);
      out[i] = last;
    }else{
      out[i] = last; // can remain null until first observation
    }
  }
  return out;
}

function rollingMean(arr, window){
  const out = new Array(arr.length).fill(null);
  let sum = 0;
  let count = 0;
  const q = []; // store values for window
  for(let i=0;i<arr.length;i++){
    const v = arr[i];
    q.push(v);
    if(v !== null && Number.isFinite(v)){
      sum += v; count += 1;
    }
    if(q.length > window){
      const old = q.shift();
      if(old !== null && Number.isFinite(old)){
        sum -= old; count -= 1;
      }
    }
    // AMR-style: calendar window always 12 months; with LOCF we expect non-null after first.
    // Still guard: if count==0, keep null.
    out[i] = (count > 0 ? sum / count : null);
  }
  return out;
}

function rebaseTo1000(spine, umvArr, baseMonth){
  const baseIdx = spine.indexOf(baseMonth);
  if(baseIdx === -1) return umvArr.map(_ => null);
  const base = umvArr[baseIdx];
  if(!(base && Number.isFinite(base) && base !== 0)) return umvArr.map(_ => null);
  return umvArr.map(v => (v && Number.isFinite(v)) ? (v/base)*1000.0 : null);
}

/** -----------------------------------------
 *  Core: pooled monthly avg from raw datapts
 *  -----------------------------------------
 */

function computePooledMonthlyAverage(rows){
  // returns Map(month -> {sum, count})
  const map = new Map();
  for(const r of rows){
    let o = map.get(r.month);
    if(!o){
      o = {sum:0, count:0};
      map.set(r.month, o);
    }
    o.sum += r.value;
    o.count += 1;
  }
  return map;
}

function monthlyAvgMapFromSumCount(sumCountMap){
  const out = new Map();
  for(const [m, sc] of sumCountMap.entries()){
    if(sc.count > 0) out.set(m, sc.sum / sc.count);
  }
  return out;
}

function computeGroupIndex(rows, baseMonth=197601, window=12){
  const sc = computePooledMonthlyAverage(rows);
  const months = Array.from(sc.keys()).sort((a,b)=>a-b);
  const minMonth = months[0];
  const maxMonth = months[months.length-1];
  const spine = buildMonthSpine(minMonth, maxMonth);

  const monthAvg = monthlyAvgMapFromSumCount(sc);
  const filled = locfFill(spine, monthAvg);
  const umv = rollingMean(filled, window);
  const idx = rebaseTo1000(spine, umv, baseMonth);

  return {spine, monthAvg, filled, umv, idx, sc};
}

/** ------------------------------------------------
 *  Contributors (v1): fast leave-one-out on monthly
 *  ------------------------------------------------
 *  We compute:
 *    Group monthly sum/count  (already have)
 *    Each artist monthly sum/count
 *  Then for each artist we produce "pooled monthly avg excluding artist"
 *  and run LOCF + UMV + rebase, and measure impact on latest index value.
 */

function computeArtistMonthSumCount(rows){
  // Map(artist -> Map(month -> {sum,count}))
  const out = new Map();
  for(const r of rows){
    let m = out.get(r.artist);
    if(!m){ m = new Map(); out.set(r.artist, m); }
    let sc = m.get(r.month);
    if(!sc){ sc = {sum:0, count:0}; m.set(r.month, sc); }
    sc.sum += r.value;
    sc.count += 1;
  }
  return out;
}

function computeIndexFromSumCount(groupSC, spine, baseMonth=197601, window=12){
  // groupSC: Map(month -> {sum,count})
  // spine: full calendar month list
  const monthAvg = new Map();
  for(const m of spine){
    const sc = groupSC.get(m);
    if(sc && sc.count > 0) monthAvg.set(m, sc.sum / sc.count);
  }
  const filled = locfFill(spine, monthAvg);
  const umv = rollingMean(filled, window);
  const idx = rebaseTo1000(spine, umv, baseMonth);
  return {idx, umv};
}

function topContributorsLatest(rows, groupObj, baseMonth=197601, window=12, topN=10){
  const {spine, sc: groupSC, idx: groupIdx} = groupObj;
  const latestIdxVal = groupIdx[groupIdx.length-1];
  const latestMonth = spine[spine.length-1];

  const byArtist = computeArtistMonthSumCount(rows);
  const artists = Array.from(byArtist.keys()).sort((a,b)=>a-b);

  const results = [];
  for(const artist of artists){
    // Build adjusted group sum/count excluding this artist month-by-month
    const artistSC = byArtist.get(artist);

    const adj = new Map();
    for(const m of spine){
      const g = groupSC.get(m) || {sum:0,count:0};
      const a = artistSC.get(m) || {sum:0,count:0};
      const sum = g.sum - a.sum;
      const count = g.count - a.count;
      if(count > 0){
        adj.set(m, {sum, count});
      }else{
        // no transactions left that month -> treat as missing for LOCF
        // by leaving it absent (monthAvg missing), LOCF will fill
      }
    }

    const {idx: idxEx} = computeIndexFromSumCount(adj, spine, baseMonth, window);
    const exVal = idxEx[idxEx.length-1];

    if(Number.isFinite(latestIdxVal) && Number.isFinite(exVal)){
      const impactSigned = latestIdxVal - exVal;
      const impactAbs = Math.abs(impactSigned);
      results.push({artist, impactSigned, impactAbs});
    }
  }

  results.sort((a,b)=>b.impactAbs - a.impactAbs);
  return {latestMonth, latestIdxVal, rows: results.slice(0, topN)};
}

/** ---------------------------
 *  Plot
 *  ---------------------------
 */

function drawChart(groupObj){
  const {spine, idx} = groupObj;

  const x = spine.map(monthToDate);
  const y = idx;

  const trace = {
    x, y,
    type:'scatter',
    mode:'lines',
    line:{width:2},
    hovertemplate:'%{x|%b %Y}<br>Index: %{y:.1f}<extra></extra>',
    name:'Group Index (rebased 1000)'
  };

  const layout = {
    margin:{l:55,r:15,t:10,b:40},
    paper_bgcolor:'rgba(0,0,0,0)',
    plot_bgcolor:'#fff',
    xaxis:{
      tickformat:'%Y',
      showgrid:true,
      zeroline:false
    },
    yaxis:{
      title:'Index (Jan 1976 = 1000)',
      showgrid:true,
      zeroline:false
    },
    showlegend:false
  };

  const config = {responsive:true, displayModeBar:false};

  Plotly.newPlot('chart', [trace], layout, config);
}

/** ---------------------------
 *  UI
 *  ---------------------------
 */

let RAW = null;
let GROUP = null;

const fileEl = document.getElementById('file');
const btnContrib = document.getElementById('btnContrib');
const btnReset = document.getElementById('btnReset');
const meta = document.getElementById('meta');
const contrib = document.getElementById('contrib');
const pillMonth = document.getElementById('pillMonth');

fileEl.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if(!f) return;
  const text = await f.text();

  try{
    RAW = parseCSV(text);

    if(RAW.length < 1000){
      meta.innerHTML = `Loaded <b>${RAW.length.toLocaleString()}</b> rows. That seems low for a full index export — but I'll proceed.`;
    }else{
      meta.innerHTML = `Loaded <b>${RAW.length.toLocaleString()}</b> raw datapoints. Building pooled group index (monthly avg → LOCF → UMV 12M → rebase 197601).`;
    }

    GROUP = computeGroupIndex(RAW, 197601, 12);
    drawChart(GROUP);

    btnContrib.disabled = false;
    btnReset.disabled = false;

    contrib.innerHTML = `<div class="muted">Press “Show contributors” to rank artists by their impact on the latest index level.</div>`;
    pillMonth.textContent = `${Math.floor(GROUP.spine[GROUP.spine.length-1]/100)}-${String(GROUP.spine[GROUP.spine.length-1]%100).padStart(2,'0')}`;
  }catch(err){
    meta.innerHTML = `<span style="color:#b00020"><b>Error:</b> ${err.message}</span>`;
    btnContrib.disabled = true;
    btnReset.disabled = true;
    contrib.innerHTML = '';
    pillMonth.textContent = '—';
  }
});

btnContrib.addEventListener('click', () => {
  if(!RAW || !GROUP) return;

  btnContrib.disabled = true;
  btnContrib.textContent = 'Working…';

  // run in a timeout so UI updates first
  setTimeout(() => {
    try{
      const {latestMonth, latestIdxVal, rows} = topContributorsLatest(RAW, GROUP, 197601, 12, 10);

      pillMonth.textContent = `${Math.floor(latestMonth/100)}-${String(latestMonth%100).padStart(2,'0')}`;

      let html = `
        <div class="small">
          Latest index level: <b>${latestIdxVal.toFixed(1)}</b>
        </div>
        <table>
          <thead>
            <tr>
              <th>ArtistID</th>
              <th class="right">Impact</th>
              <th class="right">Abs</th>
            </tr>
          </thead>
          <tbody>
      `;
      for(const r of rows){
        html += `
          <tr>
            <td>${r.artist}</td>
            <td class="right">${r.impactSigned.toFixed(2)}</td>
            <td class="right">${r.impactAbs.toFixed(2)}</td>
          </tr>
        `;
      }
      html += `</tbody></table>`;
      contrib.innerHTML = html;

    }catch(err){
      contrib.innerHTML = `<div style="color:#b00020"><b>Error:</b> ${err.message}</div>`;
    }finally{
      btnContrib.disabled = false;
      btnContrib.textContent = 'Show contributors (latest month)';
    }
  }, 50);
});

btnReset.addEventListener('click', () => {
  RAW = null;
  GROUP = null;
  fileEl.value = '';
  btnContrib.disabled = true;
  btnReset.disabled = true;
  meta.innerHTML = `Upload a CSV exported from SQL with columns: <b>ArtistID</b>, <b>MonthYYYYMM</b>, <b>ValueGBP</b>.
      This builds a pooled group index using: monthly average → LOCF → 12M rolling UMV → rebased to 1000 at 197601.`;
  contrib.innerHTML = '';
  pillMonth.textContent = '—';
  Plotly.purge('chart');
});
</script>
</body>
</html>

