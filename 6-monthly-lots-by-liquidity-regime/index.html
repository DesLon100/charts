<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>6-monthly lots by liquidity regime</title>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<style>
  body{
    margin:0;
    padding:14px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:transparent;
  }
  .wrap{ max-width:645px; }

  .controls{
    display:flex;
    gap:10px;
    margin-bottom:10px;
    flex-wrap:wrap;
    align-items:center;
  }

  input[type="file"]{ height:40px; background:#fff; }

  #chart{ width:100%; height:410px; }

  #status{
    margin-top:8px;
    font-size:12px;
    background:#fff;
    padding:8px 10px;
    border:1px solid #ddd;
    border-radius:10px;
    display:none;
    white-space:pre-wrap;
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="controls">
    <input type="file" id="fileInput" accept=".csv,.txt,text/csv,text/plain">
  </div>

  <div id="chart"></div>
  <div id="status"></div>
</div>

<script>
  const fileInput = document.getElementById("fileInput");
  const statusEl  = document.getElementById("status");

  function status(msg){
    statusEl.textContent = msg;
    statusEl.style.display = "block";
  }
  function clearStatus(){
    statusEl.textContent = "";
    statusEl.style.display = "none";
  }

  // Show JS errors on-page (so it's never mysterious)
  window.addEventListener("error", (e) => {
    status("JS error:\n" + (e.message || e.type) + "\n" + (e.filename || "") + ":" + (e.lineno || ""));
  });

  if (typeof Plotly === "undefined") {
    status("Plotly failed to load. Check internet or blocked scripts.");
  } else {
    status("Page loaded. Upload a CSV to render liquidity-regime bands.");
    setTimeout(clearStatus, 1200);
  }

  fileInput.addEventListener("change", async () => {
    clearStatus();
    const file = fileInput.files?.[0];
    if (!file) return;

    try{
      const text = await file.text();
      const parsed = parseTable(text);

      const required = ["period_start","illiquid_2_5","intermediate_6_19","liquid_20_plus"];
      for (const k of required){
        if (!(k in parsed.idx)) throw new Error(`Missing column: ${k}`);
      }

      const x  = [];
      const yI = [];
      const yM = [];
      const yL = [];

      for (const row of parsed.rows){
        let psRaw = String(row[parsed.idx.period_start] ?? "").trim();
        psRaw = psRaw.replace(/T.*$/, "").replace(/\s+\d\d:.*$/, "");
        const psDate = parsePeriodStart(psRaw);
        if (!psDate) continue;

        const ill = toNumber(row[parsed.idx.illiquid_2_5]);
        const mid = toNumber(row[parsed.idx.intermediate_6_19]);
        const liq = toNumber(row[parsed.idx.liquid_20_plus]);

        x.push(psDate);
        yI.push(isFinite(ill) ? ill : 0);
        yM.push(isFinite(mid) ? mid : 0);
        yL.push(isFinite(liq) ? liq : 0);
      }

      if (!x.length){
        Plotly.purge("chart");
        status("No valid rows found.\nExpected columns:\nperiod_start, illiquid_2_5, intermediate_6_19, liquid_20_plus");
        return;
      }

      status(
        `Loaded ${parsed.rows.length} data rows\n` +
        `Plotted ${x.length} half-year periods.\nRendering…`
      );

      draw({ x, yI, yM, yL });
      setTimeout(clearStatus, 1500);

    }catch(err){
      console.error(err);
      Plotly.purge("chart");
      status("Error:\n" + (err?.message || String(err)));
    }
  });

  // Detect delimiter (comma/tab/semicolon) and parse header + rows
  function parseTable(text){
    const clean = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").trim();
    const lines = clean.split("\n").filter(l => l.trim().length);
    if (lines.length < 2) throw new Error("File has no data rows.");

    const headerLine = lines[0];

    const candidates = [",", "\t", ";"];
    let delim = ",";
    let best = -1;
    for (const d of candidates){
      const c = headerLine.split(d).length;
      if (c > best){ best = c; delim = d; }
    }

    const header = headerLine.split(delim).map(s => s.trim());
    const idx = Object.fromEntries(header.map((h,i)=>[h,i]));

    const rows = [];
    for (let i=1; i<lines.length; i++){
      const parts = lines[i].split(delim);
      while (parts.length < header.length) parts.push("");
      rows.push(parts.map(s => String(s).trim()));
    }

    return { header, idx, rows, delim };
  }

  function toNumber(v){
    const s = String(v ?? "").trim();
    if (!s) return NaN;
    const cleaned = s.replace(/£/g,"").replace(/\s/g,"").replace(/,/g,"");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : NaN;
  }

  function parsePeriodStart(s){
    if (!s) return null;

    // ISO: YYYY-MM-DD
    const iso = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
    if (iso){
      const y = +iso[1], m = +iso[2], d = +iso[3];
      return new Date(Date.UTC(y, m - 1, d));
    }

    // Slash: d/m/yyyy or m/d/yyyy (disambiguate for half-year starts)
    const sl = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
    if (sl){
      const a = +sl[1], b = +sl[2], y = +sl[3];

      // Your periods should be Jan 1 or Jul 1.
      let day, month;
      if (a === 1 && (b === 1 || b === 7)) { day = 1; month = b; }
      else if (b === 1 && (a === 1 || a === 7)) { day = 1; month = a; }
      else { day = a; month = b; } // fallback UK (day/month)

      if (month < 1 || month > 12) return null;
      return new Date(Date.UTC(y, month - 1, day));
    }

    return null;
  }

  function buildYearDividers(xDates){
    // "Small dividers for missing years": draw faint vertical lines each Jan 1.
    const years = xDates.map(d => d.getUTCFullYear());
    const minY = Math.min(...years);
    const maxY = Math.max(...years);

    const shapes = [];
    for (let y = minY; y <= maxY; y++){
      const d = new Date(Date.UTC(y, 0, 1));
      shapes.push({
        type: "line",
        xref: "x",
        yref: "paper",
        x0: d, x1: d,
        y0: 0, y1: 1,
        line: { width: 1 },
        opacity: 0.18,
        layer: "below"
      });
    }
    return shapes;
  }

  function draw({ x, yI, yM, yL }){
    // Keep vertical stacking order the same as before:
    // bottom = Illiquid, middle = Intermediate, top = Liquid
    // Legend should be a row above the chart, left-to-right, with an extra "Regimes" label.
    const traces = [
      // Dummy legend label (no visible line/marker)
      {
        x: [x[0]], y: [0],
        type: "scatter",
        mode: "lines",
        name: "Regimes:",
        showlegend: true,
        hoverinfo: "skip",
        line: { width: 0 }
      },

      // Stack group (order controls vertical stacking)
      { x, y: yI, type:"scatter", mode:"lines", name:"Illiquid (2–5)",       stackgroup:"one", line:{ width:0.5 } },
      { x, y: yM, type:"scatter", mode:"lines", name:"Intermediate (6–19)", stackgroup:"one", line:{ width:0.5 } },
      { x, y: yL, type:"scatter", mode:"lines", name:"Liquid (≥20)",        stackgroup:"one", line:{ width:0.5 } }
    ];

    Plotly.newPlot("chart", traces, {
      paper_bgcolor: "rgba(0,0,0,0)",
      plot_bgcolor: "rgba(0,0,0,0)",

      // Space for the legend row above plot
      margin: { l: 88, r: 10, t: 44, b: 55 },

      yaxis: {
        title: "Aggregated sold lots",
        rangemode: "tozero",
        zeroline: false
      },

      xaxis: {
        type: "date",
        title: "",
        tickformat: "%Y",
        dtick: "M24",              // every 2 years
        tick0: "2010-01-01",        // anchor to a clean even year
        hoverformat: "%Y-%m-%d",
        automargin: true
      },

      // faint yearly dividers
      shapes: buildYearDividers(x),

      // Legend as a single row above the plot (left-to-right)
      legend: {
        orientation: "h",
        x: 0,
        y: 1.18,
        xanchor: "left",
        yanchor: "top",
        bgcolor: "rgba(255,255,255,0.7)",
        bordercolor: "rgba(0,0,0,0.15)",
        borderwidth: 1,
        font: { size: 12 }
      }

    }, {
      displayModeBar: false,
      responsive: true
    });
  }
</script>
</body>
</html>
