<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>6-monthly lots by liquidity regime</title>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<style>
  body{
    margin:0;
    padding:14px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:transparent;
  }
  .wrap{ max-width:645px; }

  .controls{
    display:flex;
    gap:10px;
    margin-bottom:10px;
    flex-wrap:wrap;
    align-items:center;
  }

  input[type="file"]{ height:40px; background:#fff; }

  #chart{ width:100%; height:410px; }

  #status{
    margin-top:8px;
    font-size:12px;
    background:#fff;
    padding:8px 10px;
    border:1px solid #ddd;
    border-radius:10px;
    display:none;
    white-space:pre-wrap;
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="controls">
    <input type="file" id="fileInput" accept=".csv,.txt,text/csv,text/plain">
  </div>

  <div id="chart"></div>
  <div id="status"></div>
</div>

<script>
  const fileInput = document.getElementById("fileInput");
  const statusEl  = document.getElementById("status");

  function status(msg){
    statusEl.textContent = msg;
    statusEl.style.display = "block";
  }
  function clearStatus(){
    statusEl.textContent = "";
    statusEl.style.display = "none";
  }

  window.addEventListener("error", (e) => {
    status("JS error:\n" + (e.message || e.type) + "\n" + (e.filename || "") + ":" + (e.lineno || ""));
  });

  if (typeof Plotly === "undefined") {
    status("Plotly failed to load. Check internet or blocked scripts.");
  } else {
    status("Page loaded. Upload a CSV to render liquidity-regime bands.");
    setTimeout(clearStatus, 1200);
  }

  fileInput.addEventListener("change", async () => {
    clearStatus();
    const file = fileInput.files?.[0];
    if (!file) return;

    try{
      const text = await file.text();
      const parsed = parseTable(text);

      const required = ["period_start","illiquid_2_5","intermediate_6_19","liquid_20_plus"];
      for (const k of required){
        if (!(k in parsed.idx)) throw new Error(`Missing column: ${k}`);
      }

      const x  = [];
      const yI = [];
      const yM = [];
      const yL = [];

      for (const row of parsed.rows){
        let psRaw = String(row[parsed.idx.period_start] ?? "").trim();
        psRaw = psRaw.replace(/T.*$/, "").replace(/\s+\d\d:.*$/, "");
        const psDate = parsePeriodStart(psRaw);
        if (!psDate) continue;

        const ill = toNumber(row[parsed.idx.illiquid_2_5]);
        const mid = toNumber(row[parsed.idx.intermediate_6_19]);
        const liq = toNumber(row[parsed.idx.liquid_20_plus]);

        x.push(psDate);
        yI.push(isFinite(ill) ? ill : 0);
        yM.push(isFinite(mid) ? mid : 0);
        yL.push(isFinite(liq) ? liq : 0);
      }

      if (!x.length){
        Plotly.purge("chart");
        status("No valid rows found.\nExpected columns:\nperiod_start, illiquid_2_5, intermediate_6_19, liquid_20_plus");
        return;
      }

      status(
        `Loaded ${parsed.rows.length} data rows\n` +
        `Plotted ${x.length} half-year periods.\nRendering…`
      );

      draw({ x, yI, yM, yL });
      setTimeout(clearStatus, 1500);

    }catch(err){
      console.error(err);
      Plotly.purge("chart");
      status("Error:\n" + (err?.message || String(err)));
    }
  });

  function parseTable(text){
    const clean = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").trim();
    const lines = clean.split("\n").filter(l => l.trim().length);
    if (lines.length < 2) throw new Error("File has no data rows.");

    const headerLine = lines[0];

    const candidates = [",", "\t", ";"];
    let delim = ",";
    let best = -1;
    for (const d of candidates){
      const c = headerLine.split(d).length;
      if (c > best){ best = c; delim = d; }
    }

    const header = headerLine.split(delim).map(s => s.trim());
    const idx = Object.fromEntries(header.map((h,i)=>[h,i]));

    const rows = [];
    for (let i=1; i<lines.length; i++){
      const parts = lines[i].split(delim);
      while (parts.length < header.length) parts.push("");
      rows.push(parts.map(s => String(s).trim()));
    }

    return { header, idx, rows, delim };
  }

  function toNumber(v){
    const s = String(v ?? "").trim();
    if (!s) return NaN;
    const cleaned = s.replace(/£/g,"").replace(/\s/g,"").replace(/,/g,"");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : NaN;
  }

  function parsePeriodStart(s){
    if (!s) return null;

    const iso = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
    if (iso){
      const y = +iso[1], m = +iso[2], d = +iso[3];
      return new Date(Date.UTC(y, m - 1, d));
    }

    const sl = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
    if (sl){
      const a = +sl[1], b = +sl[2], y = +sl[3];

      let day, month;
      if (a === 1 && (b === 1 || b === 7)) { day = 1; month = b; }
      else if (b === 1 && (a === 1 || a === 7)) { day = 1; month = a; }
      else { day = a; month = b; }

      if (month < 1 || month > 12) return null;
      return new Date(Date.UTC(y, month - 1, day));
    }

    return null;
  }

  function buildYearDividers(xDates){
    const years = xDates.map(d => d.getUTCFullYear());
    const minY = Math.min(...years);
    const maxY = Math.max(...years);

    const shapes = [];
    for (let y = minY; y <= maxY; y++){
      const d = new Date(Date.UTC(y, 0, 1));
      shapes.push({
        type: "line",
        xref: "x",
        yref: "paper",
        x0: d, x1: d,
        y0: 0, y1: 1,
        line: { width: 1 },
        opacity: 0.18,
        layer: "below"
      });
    }
    return shapes;
  }

  function draw({ x, yI, yM, yL }){
    // IMPORTANT:
    // Stack order is trace order (bottom -> top).
    // Legend order is also trace order (left -> right).
    //
    // To keep the vertical stacking as:
    //   bottom Illiquid, middle Intermediate, top Liquid
    // ...we keep those traces in that order.
    //
    // To get "Liquidity regimes:" on the LEFT of the legend row,
    // we DO NOT use a dummy trace (Plotly may push it around).
    // Instead, we add an annotation above the plot area.

    const traces = [
      { x, y: yI, type:"scatter", mode:"lines", name:"Illiquid (2–5)",       stackgroup:"one", line:{ width:0.5 } },
      { x, y: yM, type:"scatter", mode:"lines", name:"Intermediate (6–19)", stackgroup:"one", line:{ width:0.5 } },
      { x, y: yL, type:"scatter", mode:"lines", name:"Liquid (≥20)",        stackgroup:"one", line:{ width:0.5 } }
    ];

    Plotly.newPlot("chart", traces, {
      paper_bgcolor: "rgba(0,0,0,0)",
      plot_bgcolor: "rgba(0,0,0,0)",

      // Extra top margin to host the legend row and the label
      margin: { l: 88, r: 10, t: 58, b: 55 },

      yaxis: {
        title: "Aggregated sold lots",
        rangemode: "tozero",
        zeroline: false
      },

      xaxis: {
        type: "date",
        tickformat: "%Y",
        dtick: "M24",        // every 2 years
        tick0: "2010-01-01",
        hoverformat: "%Y-%m-%d",
        automargin: true
      },

      // faint year dividers
      shapes: buildYearDividers(x),

      // Legend row (left-to-right) above the plot
      legend: {
        orientation: "h",
        x: 0.18,             // pushed right to make room for the label at left
        y: 1.22,
        xanchor: "left",
        yanchor: "top",
        bgcolor: "rgba(255,255,255,0.7)",
        bordercolor: "rgba(0,0,0,0.15)",
        borderwidth: 1,
        font: { size: 12 }
      },

      // Label on the same horizontal line as the legend
      annotations: [{
        text: "Liquidity regimes:",
        xref: "paper",
        yref: "paper",
        x: 0,
        y: 1.22,
        xanchor: "left",
        yanchor: "top",
        showarrow: false,
        font: { size: 12 },
        bgcolor: "rgba(255,255,255,0.7)",
        bordercolor: "rgba(0,0,0,0.15)",
        borderwidth: 1,
        borderpad: 4
      }]

    }, {
      displayModeBar: false,
      responsive: true
    });
  }
</script>
</body>
</html>
